#include "node.h"
#include "alphanum.hpp"
#include <iostream>
#include <fstream>
#include <algorithm>
//#include <windows.h> //for coloring some texts
#define V_TDR "V_TDR"

using namespace std;

//Global variables
string NW_state; //Active Network State

node* rootptr = NULL; //hold the address of the root node 
unsigned int height;
vector<selection> main_sel_clauses; //hold all the selection clauses of the network's registers
vector<connection> SDG_con_clauses; //hold all the Network connection clauses, this is a vector and not an array like 'selection* main_sel_clauses' beacuse dealing with vectors in this context will be easier and faster 
vector<reg> NW_SCBs;
vector<string>NW_TDRs;
vector<node_address> VN; //list of visited nodes, here we don't have to store a vector of nodes(huge data structure to be saved), we need oly the node name and where it saved in heap :)
vector<SDGnode_address> SDG_VN; //list of SDG visited nodes
vector<node_address> AP;//Set of the nodes in the SDG active scan path
vector<SDGnode_address> SDG_AP; //Set of the nodes in the active scan path
vector<node_address> AN;//Set of Active Nodes generated by structural retargeting techniques
vector<reg> AVs;//Set of Variable Length Access Vectors (ordered bit vector constructed from SAN, previously satisfied values and the reset values)
vector<node_address> CN; //list of conflicting nodes
vector<NWElement_statistics> target_registers; //vector of statistics of ALL NW_target registers using structured retargeting 

//2D vectors:
vector<vector<string>> n_tracedNodes;  //traced nodes are the nodes which have structrual or temporal dependencies with the target register
vector<vector<reg>> AVs_total; //AVs of all the required patterns to access a register
vector<vector<reg>> AVs_sorted; //All AVs vectors which are required to access the target but also sorted
/*
//this section is used to change cout color
CONSOLE_SCREEN_BUFFER_INFO Info;
HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
WORD currentConsoleAttr = Info.wAttributes;
*/

unsigned int noOfRootVChildren;
string SCB_SIB[] = { "SIB","SIBP", "PSIB", "SCB", "SREG", "SR" }; //there are SR: "shift register" like the one used in SIB and SR: "scan register" like the one used in TDRs, here we refer to the one used in SIB(shift register)
string TDR[] = { "R","WI","wrpInput", "wrpOutput", "wrpControl", "ScanChain", "In", "Out", "SC" };
struct SDG_node* head = NULL;

unsigned int n_CSU_cycles = 0;
unsigned int scanPath_len = 0;

node::node()
{
	reg_id = "";
	selection_clause = "";
	this->depth = 0;
	this->sat_value = -1; //The default is that the node's state value is (unkown) or (uninitialized) until serial bits with real valuse are shifted to the iJtag Network. (-1) <--> (unknown/uninitialized) value
	this->reset = 0;
	this->active = false; //initially all nodes are (inactive, unsatisfied)
	this->satisfied = false;
	this->noOfChildren = 0;
	ptrToChildren = NULL;
	weight = 0;
	length = 0;
}

node::node(string& reg_id, unsigned int depth, int sat_value)
{
	this->reg_id = reg_id;

	size_t index = get_selection_clause_index(reg_id);
	//Vector Assignmnet//
	//So we can see that vector assignment is 55.38% faster than Insert() and  89% faster than push_back(). Caution: Do not use std::vector::swap. std::vector::swap is not copying a vector to another, it is actually swapping elements of two vectors, just as its name suggests. In other words, the source vector to copy from is modified after std::vector::swap is called, which is probably not what you are expected.
	selection_clause = main_sel_clauses[index].selectionClause;
	this->length = main_sel_clauses[index].reg_len;
	this->reset = main_sel_clauses[index].reset_val;

	this->depth = depth;
	this->sat_value = sat_value; // root node always not satisfied, for the other nodes 'sat_value' can be inferred from the selection clause

	//This is only the initial values, which will be modified while applying different code sections
	this->active = false;
	this->satisfied = false;
	this->weight = 0;

	if (selection_clause == "TRUE" || selection_clause == "true") //it means it is a leaf
	{
		this->noOfChildren = 0;
		this->ptrToChildren = NULL;
	}
	else if (!selection_clause.empty()) //or I can type just "else"
	{
		this->noOfChildren = count(selection_clause.begin(), selection_clause.end(), '^') + 1; //this part is uncomplete yet in case I have 'OR', //I can't use 'sizeof(x.next_nodes)' to find out the size of a dynamic array. The size of an array allocated with new[] is not stored in any way in which it can be accessed. Note that the return type of new [] is not an array - it is a pointer (pointing to the array's first element). So if you need to know a dynamic array's length, you have to store it separately.
		this->ptrToChildren = new node*[this->noOfChildren];
	}
}

node::node(const node& other, unsigned int depth, int sat_value) //Overloaded assignment only invoked if the object already exist! (like x=y), so (node x = y) will call the copy constructor because object x doesn't exist yet.
	:reg_id(other.reg_id), selection_clause(other.selection_clause), depth(depth), sat_value(sat_value), reset(other.reset), weight(other.weight), length(other.length), active(other.active), satisfied(other.satisfied), noOfChildren(other.noOfChildren)
{
	/*
	//This method will be called in TWO scenraios:
	1- in (vector.push_back) while enlarging the vector size at this time this method will be called through the copy constructor and at which "this->ptrToChildren" will be empty and "other" will carry the old vector data in order to be copied to the new vector, or it could be called also in (x.ptrToChildren[n] = *new node(reg_id, x.depth + 1, sat_value)), where x.ptrToChildren[n]-->this->ptrToChildren initally is empty
	2- in assigning operations through (operator =) like in (ptrToChildren[i] = other.ptrToChildren[i]; ) and at which both (*this and other) will hold data
	*/

	noOfChildren = other.noOfChildren;
	if (noOfChildren == 0)
		ptrToChildren = NULL;
	else
	{
		ptrToChildren = new node*[noOfChildren];
		for (int i = 0; i < noOfChildren; i++)
			ptrToChildren[i] = new node(*other.ptrToChildren[i], depth + 1, (*other.ptrToChildren[i]).sat_value); //take care that the depth of the copied nodes will not be the same (as sat_value "here"), so I need to update depth to be equal to (parent_depth + 1)
	}
}

void node::reserve_vectors_memory()
{
	unsigned int no_scan_segments;

	no_scan_segments = main_sel_clauses.size();

	//all the *Below* expectations are by trying and not dependant on a mathematical proved formula!!
	VN.reserve(no_scan_segments);
	AP.reserve(no_scan_segments);
	AVs.reserve(no_scan_segments);
	AN.reserve(no_scan_segments);
	CN.reserve(no_scan_segments);

	//for 2D vectors, we reserve here only the memory for outer vectors that carry each time frame information, while inner vectors would be reserved before each pushing to the outer vector.
	n_tracedNodes.reserve(max_no_timeFrames);
	AVs_total.reserve(max_no_timeFrames);
}

void node::load_NW(const string& NW_clauses_file, const string& NW_smv_pdl_file, const string& NW_SDG_file, bool retarget_all_TDRs)
{
	load_input_files(NW_clauses_file, Selection_clauses);	//to assign the main_sel_clauses and collect all NW_TDRs
	
	if (NW_SDG_file != "")//because it is usually unavailable
		load_input_files(NW_SDG_file, SDG_connections);		//to assign the SDG_con_clauses
}

void node::initialize_NW()
{
	rootptr = new node(target_registers.back().reg_id, 0, -1);
	VN.emplace_back(rootptr->reg_id, rootptr);

	n_tracedNodes.emplace_back();	//push an empty value to be adjusted later through MDFS and MPO_DFS structured retargeting
	n_tracedNodes.back().reserve(main_sel_clauses.size()); //to reserve memory for each inner vector. the amount of reservation is only some prefered value; which assumes that we are maximum going to trace all network's nodes.

	generate_SCT(*rootptr);
	update_nodes_states(*rootptr);
}

void node::initialize_NW_withConflictChecking()
{
	rootptr = new node(target_registers.back().reg_id, 0, -1);
	VN.emplace_back(rootptr->reg_id, rootptr);

	n_tracedNodes.emplace_back();  //push an empty value to be adjusted later through MDFS and MPO_DFS structured retargeting
	n_tracedNodes.back().reserve(main_sel_clauses.size());

	load_initial_NWstate();//this method have to be called first before update_nodes() and print_AP(); in order to set the node's active and satisfy attributes correctly (the calling order is important)
	generate_SCT_withConflictChecking(*rootptr);
	update_nodes_states(*rootptr);
}

node::~node()
{
	/*
	//vector.push_back(x), 'x' will create an temporary variable. After the vector copy it to its own memory, the temporary variable is destructed,
	//so this is why the destructor is called after each 'vector.push_back(x)' call.
	//in order to let the destructor work correctly I need to implement a copy constructor to do the copying operation in a coorect way, otherwise an exception will be thrown
	*/
	if (this->ptrToChildren)
	{
		for (int i = 0; i < noOfChildren; i++)
		{
			delete ptrToChildren[i];
		}
		delete[] ptrToChildren;
		this->ptrToChildren = NULL; //ptrToChildren still exists, but it's a dangling pointer now, so we set it to NULL (or 0), because delete doesn't delete the pointer, but the object it points to
	}

	this->noOfChildren = 0;
}

void node::free_memory()
{
	if (rootptr != NULL) //this condition is not required at all, it is only for safety check:)
	{
		//this part is used to free the heap memory associated with the "Target Registers' trees" creation
		for (size_t i = 0, e = VN.size(); i < e; i++)
		{
			if (!is_SCB_SIB(VN[i].reg_id)) //destroy the trees associated with each SR
			{
				destroy_tree(*VN[i].address);

				delete VN[i].address; //free the heap address of target register itself
				VN[i].address = NULL;
			}
		}

		VN.clear();
	}

	//this part is used to free the heap memory associated with the "SDG" creation
	if (head != NULL)
	{
		destroy_SDG(*head);
		//after I return back, the head node will be deallocated/freed, but not NULLed
		head = NULL;
	}
}

void node::destroy_tree(node &x)
{
	//here I have to free the heap memory associated to every node (pointers to nodes), and the memory associated to the array of pointers (pointer to array of pointers to nodes)
	if (x.ptrToChildren != NULL)
	{
		for (int j = 0; j < x.noOfChildren; j++)
		{
			destroy_tree(*x.ptrToChildren[j]);

			delete x.ptrToChildren[j]; //free the heap address of each node
			x.ptrToChildren[j] = NULL;
		}

		delete[] x.ptrToChildren; //free the heap address of the array of pointers associated to each node
		x.ptrToChildren = NULL;
		return;
	}
	return;
}

void node::destroy_SDG(SDG_node &x)
{
	if (x.next.size() != 0) //means I reached the "TDI", where the path starts from "TDO"
	{
		for (size_t i = 0, e = x.next.size(); i < e; i++)
		{
			if (x.next[i] != NULL) //if it is NULL, then it means that the next node has been deleted by another node in the NW, and this node should be handled as a leaf node and do nothing to it
			{
				destroy_SDG(*x.next[i]);
				x.next[i] = NULL;
			}
		}

		x.next.clear(); //if all the node's next children are freed, then clear the vector to set its size to zero
	}
	if (x.next.size() == 0) //this is "if" condition and not just as regular "else", to recheck for the "x.next" pointer after each call return
	{
		//before deletion check that this node hasn't any other nodes pointing to it. otherwise, other pointers should point to NULL where this node will not be existent anymore.
		if (x.prev.size() > 1) //if more than one node is pointing to this node, then set those SDG_nodes to point to NULL (set their next vector to point to NULL instead of pointing to this unexist anymore node)
		{
			SDG_node* prevNode; //to point to the node original address and not just take a "COPY" of it
			for (size_t i = 0, e1 = x.prev.size(); i < e1; i++)
			{
				prevNode = x.prev[i];
				for (size_t j = 0, e2 = prevNode->next.size(); j < e2; j++)
				{
					if (prevNode->next[j] == &x)
						prevNode->next[j] = NULL;
					break;
				}
			}
		}

		delete &x;
		return;
	}
}

void node::reset_system()
{
	free_memory();  //for (Target reg trees (SCT), SDG connection graph)
	delete_vectors();
	reset_counters();
}

void node::generate_SCT(node &x)
{
	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
	{
		return;
	}

	string reg_id = "";
	int sat_value = 1;	 //this is the default value, until we found a negation(!), or some other different state ([0100]), which should be detected through the next loop.
	int n = 0;			 //represent number of children for each node;

	//This section is used to parse the selection clause and extract all the children
	for (size_t i = 0, e = x.selection_clause.size(); i < e; i++)
	{
		while ((x.selection_clause[i] != '^') && (i < e)) // 'OR' this have to be covered also
		{
			if (x.selection_clause[i] == '!')
			{
				sat_value = 0;
			}
			else if (x.selection_clause[i] == '[')
			{
				string state; //The default constructor defines an empty string (i.e "" ) with a size/length of zero.
				while (x.selection_clause[++i] != ']')
				{
					state += x.selection_clause[i];
				}
				sat_value = stoi(state, nullptr, 2);
			}
			else if (x.selection_clause[i] != ' ')// to exclude empty spaces
			{
				reg_id += x.selection_clause[i];
			}

			i++;
		}

		//This part is used to construct the tree of each child
		int pos = find(VN.begin(), VN.end(), reg_id) - VN.begin(); //'find' look for registers with the same (reg_id) only not (reg_id, sat_value)

		//This part is used to benefit from the sub tree creation of the previously visited nodes
		//but there may be other different nodes in 'main_sel_clause' array, so I need to check for them in 'generate_AP' method
		if (pos >= VN.size())
		{
			//I need to add the node after adjusting its attributes like 'x.ptrToChildren' so that the 'is_active(node &x)' can work correctly
			x.ptrToChildren[n] = new node(reg_id, x.depth + 1, sat_value); //adjust the node depth and sat_value, which differ from node to another even if two nodes have the same sub tree, here I'm saving the node's address in heap (and not the node itself) to save more memory (object node's size will be smaller) and to use the address in free heap operation
			VN.emplace_back((*x.ptrToChildren[n]).reg_id, x.ptrToChildren[n]);
			generate_SCT(*x.ptrToChildren[n]);
		}
		else //this section to copy subTree: please note in node_copying two values could differ from one node to another(sat_value, depth), so I need to update those values seperately according to the position of each node in the SCT.
			x.ptrToChildren[n] = new node(*VN[pos].address, x.depth + 1, sat_value);

		/////////////////////////////////

		n++;
		sat_value = 1; //reset values for the next round in the loop
		reg_id.clear(); // set size of string to 0 length

		//set tree height
		if (height < x.depth + 1)
			height = x.depth + 1;
	}
}

void node::generate_SCT_withConflictChecking(node &x)
{
	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
		return;

	string reg_id = "";
	int sat_value = 1;
	int n = 0;

	for (size_t i = 0, e = x.selection_clause.size(); i < e; i++)
	{
		while ((x.selection_clause[i] != '^') && (i < e))
		{
			if (x.selection_clause[i] == '!')
				sat_value = 0;

			else if (x.selection_clause[i] == '[')
			{
				string state;
				while (x.selection_clause[++i] != ']')
				{
					state += x.selection_clause[i];
				}
				sat_value = stoi(state, nullptr, 2);
			}

			else if (x.selection_clause[i] != ' ')
				reg_id += x.selection_clause[i];

			i++;
		}

		if (x == *rootptr)
			noOfRootVChildren++;

		int pos = check_id_existence(VN, x.ptrToChildren[n]->reg_id);

		if (pos == -1)
		{
			x.ptrToChildren[n] = new node(reg_id, x.depth + 1, sat_value);
			VN.emplace_back((*x.ptrToChildren[n]).reg_id, x.ptrToChildren[n]);
			generate_SCT_withConflictChecking(*x.ptrToChildren[n]);
		}
		else
		{
			x.ptrToChildren[n] = new node(*VN[pos].address, x.depth + 1, sat_value); //here I need to check the conflict through the sub-tree of the previsited node, where it contains also other previsited nodes
			check_conflict(*x.ptrToChildren[n]); //here I check the conflict for the previsited node itself

			//there must be another method call here, to check the conflict for the subTree after copying it
		}

		n++;
		sat_value = 1;
		reg_id.clear();

		if (height < x.depth + 1)
			height = x.depth + 1;
	}
}

void node::printSDG(const SDG_node& x)
{

	cout << "node: " << x.reg_id << ", ";
	cout << "prev: ";
	if (x.prev.size() != 0)
	{
		for (size_t i = 0, e = x.prev.size(); i < e; i++)
			cout << x.prev[i]->reg_id << ", ";
	}
	else
	{
		cout << "NULL. ";
	}

	cout << "next: ";
	if (x.next.size() != 0)
	{
		for (size_t i = 0, e = x.next.size(); i < e; i++)
			cout << x.next[i]->reg_id << ", ";
	}
	else
	{
		cout << "NULL. \n";
		return;
	}
	cout << "\n";

	for (size_t i = 0, e = x.next.size(); i < e; i++)
	{
		printSDG(*x.next[i]);
	}
}

void node::generate_AP()
{
	for (size_t i = 0, e = VN.size(); i < e; i++)
	{
		if (is_active(*VN[i].address))
		{
			AP.emplace_back(VN[i]);
		}
	}
}

void node::load_initial_NWstate()
{
	//std::sort(NW_SCBs.begin(), NW_SCBs.end(), doj::alphanum_more<std::string>()); //(alphanum_more): for descending order (5,4,3,..), while (alphanum_less): for ascending order (1,2,3, ..)
	//std::copy(NW_SCBs.begin(), NW_SCBs.end(), std::ostream_iterator<std::string>(std::cout, "\n"));		//print the vector to cout (after sorting it).

	//this section is used to convert from string to bin 
	if ((NW_state.length() == 1) && (NW_SCBs.size() > 1)) //in general (NW_state.size() < NW_SCBs.size()) and specifically when (NW_state.size() == 1).
	{
		for (size_t n = 0, e = NW_SCBs.size(); n < e; n++) //here I used 'NW_SCBs_adjustedSize' and not 'NW_SCBs.size()', where I need to consider the registers length and not only their numbers while generating the NW_SCBs[n].state
			NW_SCBs[n].state = NW_state[0] - '0'; //NW_state[0] because NW_state in this case is only one bit
	}
	else // (NW_state.size() >= NW_SCBs.size())  :(>) in case that I have SCBs with more than one bit (length>1)
	{
		for (size_t n = 0, i = 0, e1 = NW_state.length(); i < e1; i++)
		{
			if (NW_SCBs[n].length == 1)
				NW_SCBs[n++].state = NW_state[i] - '0';

			else
			{
				string state = "";
				for (unsigned int j = 0; j < NW_SCBs[n].length; j++)
					state += NW_state[i++];
				NW_SCBs[n].state = stoi(state, nullptr, 2);

				i--; //to adjust the i_index (return it back) after the last decrement during the exiting from the previous loop (j_loop)
			}
		}
	}
}

void node::set_current_NWstate()
{
	for (unsigned int i = 0, e = NW_SCBs.size(); i < e; i++)
		NW_state += to_string(NW_SCBs[i].state) + " ";
}

void node::load_current_NWstate()
{
	if (NW_state == "0")
	{
		for (unsigned int i = 0, e = NW_SCBs.size(); i < e; i++)
			NW_SCBs[i].state = 0;
	}
	else 
	{
		size_t last = 0;
		size_t next = 0;
		size_t index = 0;
		string delimiter = " ";

		while ((next = NW_state.find(delimiter, last)) != string::npos)
		{
			NW_SCBs[index].state = stoi(NW_state.substr(last, next - last));
			last = next + 1;
			index++;
		}
	}
}

void node::update_SCBStates()
{
	for (size_t j = 0, e = AN.size(); j < e; j++)
	{
		int pos = check_reg_existence(NW_SCBs, AN[j].reg_id);//only some SCBs will be updated, those are the SCBs which have been changed and updated with different values through the retargeter ASP. Others will keep the same old values
		if (pos != -1)
			NW_SCBs[pos].state = (*AN[j].address).sat_value;
	}
}

void node::update_SCBStates(vector<reg> &p)
{
	for (size_t j = 0, e = p.size(); j < e; j++)
	{
		int pos = check_reg_existence(NW_SCBs, p[j].reg_id);
		if (pos != -1) //because the input vector (p) could contain SCBs and TDRs so I want to update the state of only NW_SCBs or NW_scanRegisters.  
			NW_SCBs[pos].state = p[j].state;
	}
}

bool node::is_satisfied(const node& x)
{
	for (size_t i = 0, e = NW_SCBs.size(); i < e; i++)
	{
		if (x.reg_id == NW_SCBs[i].reg_id)
		{
			if (x.sat_value == NW_SCBs[i].state)
				return true;
			else
				return false; //Not satisfied
		}
	}
	return false;
}

bool node::is_active(const node& x)
{
	//active nodes either are leaf nodes or having all children satisfied

	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
		return true;

	for (int i = 0; i < x.noOfChildren; i++)
	{
		if (!is_satisfied(*x.ptrToChildren[i]))
			return false;
	}
	return true;
}

void node::update_nodes_states(node &x)
{
	if (is_active(x))
		x.active = true;
	else
		x.active = false;

	if (is_satisfied(x))
		x.satisfied = true;
	else
		x.satisfied = false;

	// check if it is a leaf node or not
	if (x.ptrToChildren != NULL)
	{
		for (int i = 0; i < x.noOfChildren; i++)
			update_nodes_states(*x.ptrToChildren[i]);
	}
	else
		return;
}

void node::MPO_DFS(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);

	while (!(*rootptr).active)
	{
		if (!x.active)
		{
			if (!x.satisfied) //1- (!Active ^ !Satisfied)
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MPO_DFS(*x.ptrToChildren[i]);
					/* //this condition can be used in optimization but for now let's keep it coherant with Dr. pesuode code, we need to do post order depth first search (loop on ALL children before return back to the parent)
					if ((*rootptr).active) //this condition is needed to stop traversing the remaining root's children if conflict has been resolved, (where if any deep node caused any dissatisfaction to root's children, then we need to re-traverse root's children to satisfy them again, but we don't have to traverse them all or in other words we should stop by the moment at which the target register become accessible)
					{
						break; //this cond can be used also as a code ENHANCEMENT, where even for non conflict situations, in MPO_DFS satisfying deepest nodes first may satisfy also root's children and higher nodes (above nodes), so in some cases like after tree sorting I may found that with later cycles, all the remaining root's children are already satisfied even without traversing them.
					}
					*/
				}

				//recheck the parent after satisfying its children, it may now been activated
				if (x.active && (x.reg_id != rootptr->reg_id)) //not to include root node in this condition, to resolve any upcoming conflict
				{
					n_tracedNodes.back().emplace_back(x.reg_id);   //to include the parent RE-Tracing

					int pos = check_id_existence(AN, x.reg_id);
					if (pos == -1) //(-1) means there is no node with the same (reg_id)
						AN.emplace_back(x.reg_id, &x);

					else //if this node exists before in AN, then don't push it again but only update it with the new 'sat_value'
						(*AN[pos].address).sat_value = x.sat_value;

					satisfy_node();
					n_tracedNodes.emplace_back();
					n_tracedNodes.back().reserve(main_sel_clauses.size());
					return;
				}
				else if (x.reg_id == rootptr->reg_id) //and (x.active or !a.active),I have to include the root_reg as a re-traced node; because "n_tracedNodes.back().push_back(x.reg_id)" is outside the while loop "while (!(*rootptr).active)", so when I return to the while the target_reg will not be considered
				{
					n_tracedNodes.back().emplace_back(x.reg_id);
				}
			}
			//2- (!Active ^ Satisfied)
			if (x.reg_id != rootptr->reg_id) //this cond is required for dynamic conflict resolution; where earlier nodes (root's children) may become unsatisfied while traversing, so I need to continue looping on them until they become so
				return;
		}
		else if (!x.satisfied)//3- (Active ^ !Satisfied)
		{
			int pos = check_id_existence(AN, x.reg_id);
			if (pos == -1)
				AN.emplace_back(x.reg_id, &x);

			else //if this node exists before in AN, then don't push it again and update it only with the new 'sat_value'
				AN[pos].address->sat_value = x.sat_value;

			satisfy_node(); //Even if AN is cleared each satisfying time, Old AN values would be already saved in SCBState vector while calling 'update_SCBState()' method to transfer the satisfying action to the network current state by setting the SCB/SIB
			n_tracedNodes.emplace_back();
			n_tracedNodes.back().reserve(main_sel_clauses.size());
			return;
		}
		else //4- (Active ^ Satisfied), then there is no need to shift a dedicated vector for satisfying it.
			return;
	}
	/*
	//Print the final active scan path when the target register could be accessed
	if(x == *rootptr) //this condition is needed because one branch may satisfy also the remaining root's children, so when I do the recursion for them the while loop will be already satisfied
		generate_AVs(); //to concatenate AVs, I have to call [generate_AVs, generate_AP()] without calling AN.clear(); to concatenate active node each time
	*/
}

void node::MPO_DFS_writeModel(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);

	while ((*rootptr).sat_value == -1)
	{
		if (!x.active)
		{
			if (!x.satisfied) //1- (!Active ^ !Satisfied)
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MPO_DFS_writeModel(*x.ptrToChildren[i]);
					/* //this condition can be used in optimization but for now let's keep it coherant with Dr. pesuode code, we need to do post order depth first search (loop on ALL children before return back to the parent)
					if ((*rootptr).active) //this condition is needed to stop traversing the remaining root's children if conflict has been resolved, (where if any deep node caused any dissatisfaction to root's children, then we need to re-traverse root's children to satisfy them again, but we don't have to traverse them all or in other words we should stop by the moment at which the target register become accessible)
					{
						break; //this cond can be used also as a code ENHANCEMENT, where even for non conflict situations, in MPO_DFS satisfying deepest nodes first may satisfy also root's children and higher nodes (above nodes), so in some cases like after tree sorting I may found that with later cycles, all the remaining root's children are already satisfied even without traversing them.
					}
					*/
				}

				//recheck the parent after satisfying its children, it may now been activated
				if (x.active && (x.reg_id != rootptr->reg_id)) //not to include root node in this condition, to resolve any upcoming conflict
				{
					n_tracedNodes.back().emplace_back(x.reg_id);   //to include the parent RE-Tracing
					AN.emplace_back(x.reg_id, &x);

					satisfy_node();
					n_tracedNodes.emplace_back();
					n_tracedNodes.back().reserve(main_sel_clauses.size());
					return;
				}
				else if (x.reg_id == rootptr->reg_id) //and (x.active or !a.active),I have to include the root_reg as a re-traced node; because "n_tracedNodes.back().push_back(x.reg_id)" is outside the while loop "while ((*rootptr).sat_value == -1)", so when I return to the while the target_reg will not be considered
				{
					n_tracedNodes.back().emplace_back(x.reg_id);
				}
			}
			//2- (!Active ^ Satisfied)
			if (x.reg_id != rootptr->reg_id) //this cond is required for dynamic conflict resolution; where earlier nodes (root's children) may become unsatisfied while traversing, so I need to continue looping on them until they become so
				return;
		}
		else if (!x.satisfied)//3- (Active ^ !Satisfied)
		{
			AN.emplace_back(x.reg_id, &x);

			satisfy_node(); //Even if AN is cleared each satisfying time, Old AN values would be already saved in SCBState vector while calling 'update_SCBState()' method to transfer the satisfying action to the network current state by setting the SCB/SIB
			n_tracedNodes.emplace_back();
			n_tracedNodes.back().reserve(main_sel_clauses.size());
			return;
		}
		else //4- (Active ^ Satisfied), then there is no need to shift a dedicated vector for satisfying it.
			return;
	}
	/*
	//Print the final active scan path when the target register could be accessed
	if(x == *rootptr) //this condition is needed because one branch may satisfy also the remaining root's children, so when I do the recursion for them the while loop will be already satisfied
		generate_AVs(); //to concatenate AVs, I have to call [generate_AVs, generate_AP()] without calling AN.clear(); to concatenate active node each time
	*/
}

void node::MDFS(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);

	while (!(*rootptr).active)
	{
		if (!x.active)
		{
			if (!x.satisfied) //Not Active and Not Satisfied
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MDFS(*x.ptrToChildren[i]);
				}

				if (&x == rootptr) //I can't reach here unless if the MDFS for the whole tree is completed and I returned back by recursion to the first point (root node) 
				{
					//If I reached here it means a complete tree traversal has been done
					MDFS_conflict_resolution();		//to generate SAN (Set of Selected Active Nodes) from AN 
					satisfy_node();

					n_tracedNodes.emplace_back();	//new row for the next tree traversal
					n_tracedNodes.back().reserve(main_sel_clauses.size());
					n_tracedNodes.back().emplace_back(rootptr->reg_id);
					//OR I can only say (n_tracedNodes.push_back({ rootptr->reg_id });) instead of above three commands, but above is better performance wise, where I reserve expected memory allocated each time so that no vector's resizing could happen.
				}
				else // (if x != *rootptr) this check is done after looping on all node's children.
					return;
			}
			else //Not Active but Satisfied
				return;
		}
		else //Active node
		{
			AN.emplace_back(x.reg_id, &x);
			return;
		}
		////Any return above means take the next node (next child) inside the recursion of 'MDFS(x.ptrToChildren[i]);'////

	//Carry out a new traversal until the root node becomes active
	}
	//Print the final active scan path with the target register being accessed
	//generate_AVs();
}

void node::MDFS_writeModel(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);

	while ((*rootptr).sat_value == -1)
	{
		if (!x.active)
		{
			if (!x.satisfied) //Not Active and Not Satisfied
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MDFS_writeModel(*x.ptrToChildren[i]);
				}

				if (&x == rootptr) //I can't reach here unless if the MDFS for the whole tree is completed and I returned back by recursion to the first point (root node) 
				{
					//If I reached here it means a complete tree traversal has been done
					MDFS_conflict_resolution();		//to generate SAN (Set of Selected Active Nodes) from AN 
					satisfy_node();

					n_tracedNodes.emplace_back();	//new row for the next tree traversal
					n_tracedNodes.back().reserve(main_sel_clauses.size());
					n_tracedNodes.back().emplace_back(rootptr->reg_id);
					//OR I can only say (n_tracedNodes.push_back({ rootptr->reg_id });) instead of above three commands, but above is better performance wise, where I reserve expected memory allocated each time so that no vector's resizing could happen.
				}
				else // (if x != *rootptr) this check is done after looping on all node's children.
					return;
			}
			else //Not Active but Satisfied
				return;
		}
		else //Active node
		{
			AN.emplace_back(x.reg_id, &x);

			if (&x == rootptr) //if the active node is the root, then the root(target_reg) is active but not satisfied!! So, I need to satisfy it with the right 'sat_value'
				satisfy_node();
			return;
		}
		////Any return above means take the next node (next child) inside the recursion of 'MDFS(x.ptrToChildren[i]);'////

	//Carry out a new traversal until the root node becomes active
	}
	//Print the final active scan path with the target register being accessed
	//generate_AVs();
}

void node::MDFS_conflict_resolution()
{
	//if (AN[i].address->depth > AN[j].address->depth) //keep the one with the largest depth or the deepest one --> erase(j).
	//else if(AN[i].address->depth < AN[j].address->depth) --> erase(i).
	//else //(*AN[i].address).depth == (*AN[j].address).depth, then choose the "most left one", or the one "whose inserted first" in the [AN] vector, i.e. the one with the "smaller index". and because we are sure that (j_index > i_index), since we have started from (j=i+1), --> erase(j).

	size_t i, j;

	for (i = 0; i < (unsigned int)AN.size() - 1; i++) //I can't add (e1 = AN.size() - 1, e2 = AN.size();) because it needs to be "redetermined" each loop since some inner modifications (like erase action) is done on (AN) vector each iteration.
	{
		j = i + 1;
		while (j < (unsigned int)AN.size())
		{
			if (AN[i].reg_id == AN[j].reg_id)
			{
				if (AN[i].address->depth > AN[j].address->depth || (*AN[i].address).depth == (*AN[j].address).depth)
					AN.erase(AN.begin() + j);
				else
				{
					AN[i] = AN[j]; //this section to adjust the indices if AN[i].depth < AN[j].depth
					AN.erase(AN.begin() + j); //(+j) not (+i) because I already stored A[j] into A[i]
				}
			}//No j++; because the erase action made the pointer automatically points to the next element, no need for increment
			else
				j++; //check the conflict of the next element
		}
	}
}

void node::generate_AVs() //used to generate ordered bit vector constructed from SAN, previously satisfied and the reset values
{
	int state, pos;

	//AVs is generated using the AN and AP vectors: //I need also to consider "active" but "not_MDFS_traversed" nodes while generating the ASP. I may have some "Active" nodes with (satisfied children) however those nodes were not traversed in the SCT and hence were not added to the AN vector; may be because the node's parent was already active or satisfied so MDFS traversal stops before reaching to those nodes; that's why we may found (AP.size() > AN.size())
	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		//only 'state' value needs to be re-adjusted based on the node's associativity (if it is belong to AN, then it needs to be satisfied with the required 'sat_value', if it is not and it was an SCB/SIB then use its corresponding 'state' value from the SCBState vector, otherwise reset it to be excluded from the A.S.P)
		pos = check_id_existence(AN, AP[i].address->reg_id);
		if (pos != -1)
			state = (*AN[pos].address).sat_value;
		else //if it is an SCB/SIB, then set it based on its old value which was shifter through the last CSU, however, to get this value, seek on it in the NW_SCBs vector (its value in the previous CSU should be shifted and updated in NW_current_state or NW_SCB_states), otherwise use the SCBs' reset_value .
		{
			pos = check_reg_existence(NW_SCBs, AP[i].reg_id);
			if (pos != -1)
				state = NW_SCBs[pos].state;
		}

		AVs.emplace_back(AP[i].reg_id, state, (*AP[i].address).length);
	}
	AVs_total.emplace_back(AVs);

	n_CSU_cycles++;
	adjust_scanPath_len();
}

void node::generate_AVs(vector<node_address> &AN) //used to generate ordered bit vector constructed from SAN, previously satisfied and the reset values
{
	int state, pos;

	//AVs is generated using the AN and AP vectors: //I need also to consider "active" but "not_MDFS_traversed" nodes while generating the ASP. I may have some "Active" nodes with (satisfied children) however those nodes were not traversed in the SCT and hence were not added to the AN vector; may be because the node's parent was already active or satisfied so MDFS traversal stops before reaching to those nodes; that's why we may found (AP.size() > AN.size())
	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		//only 'state' value needs to be re-adjusted based on the node's associativity (if it is belong to AN, then it needs to be satisfied with the required 'sat_value', if it is not and it was an SCB/SIB then use its corresponding 'state' value from the SCBState vector, otherwise reset it to be excluded from the A.S.P)
		pos = check_id_existence(AN, AP[i].address->reg_id);
		if (pos != -1)
			state = (*AN[pos].address).sat_value;
		else //if it is an SCB/SIB, then set it based on its old value which was shifter through the last CSU, however, to get this value, seek on it in the NW_SCBs vector (its value in the previous CSU should be shifted and updated in NW_current_state or NW_SCB_states), otherwise use the SCBs' reset_value .
		{
			pos = check_reg_existence(NW_SCBs, AP[i].reg_id);
			if (pos != -1)
				state = NW_SCBs[pos].state;
		}

		AVs.emplace_back(AP[i].reg_id, state, (*AP[i].address).length);
	}
	AVs_total.emplace_back(AVs);

	n_CSU_cycles++;
	adjust_scanPath_len();
}

void node::print_AVs()
{
	for (size_t n = 0, e = AVs.size(); n < e; n++)
	{
		if (is_SCB_SIB(AVs[n].reg_id))
		{
			cout << AVs[n].reg_id << ": ";
			for (int i = AVs[n].length - 1; i >= 0; i--)//FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
			{
				cout << ((AVs[n].state >> i) & 1);
			}
			cout << ", ";
		}
		else //for TDR access print 'XXX'
		{
			cout << AVs[n].reg_id << ": " << "X, ";
		}

	}
	cout << "\n\n";
}

void node::print_AVs_total()
{
	for (size_t i = 0, e1 = AVs_total.size(); i < e1; i++)
	{
		cout << "CSU(" << i + 1 << "): ";
		for (size_t j = 0, e2 = AVs_total[i].size(); j < e2; j++)
		{
			if (is_SCB_SIB(AVs_total[i][j].reg_id))
			{
				cout << AVs_total[i][j].reg_id << ": ";
				cout << AVs_total[i][j].state;							//print decimal value
				/*for (int n = AVs_total[i][j].length - 1; n >= 0; n--)	//n should be (int) to be able to hold (-1). FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
				{
					cout << ((AVs_total[i][j].state >> n) & 1);			//print binary value
				}*/
				cout << ", ";
			}
			else //for TDR access print 'XXX'
			{
				cout << AVs_total[i][j].reg_id << ": " << "X, ";
			}
		}
		cout << "\n\n";
	}
}

void node::clear_vectors()
{
	//clear used vectors to be used again in the next retargeting TDR. (VN.clear();) is called inside free_memory(). After deAllocating associated heap_memory
	AVs.clear();
	AN.clear();
	AP.clear();
	CN.clear();
	SDG_AP.clear();
	SDG_VN.clear();
	NW_state = "";

	//clear 2D vectors
	//n_tracedNodes:
	for (size_t i = 0, e = n_tracedNodes.size(); i < e; i++)
		std::vector<string>().swap(n_tracedNodes[i]);
	n_tracedNodes.clear();
	//AVs_total:
	for (size_t i = 0, e = AVs_total.size(); i < e; i++)
		std::vector<reg>().swap(AVs_total[i]);
	AVs_total.clear();
	//AVs_sorted:
	for (size_t i = 0, e = AVs_sorted.size(); i < e; i++)
		std::vector<reg>().swap(AVs_sorted[i]);
	AVs_sorted.clear();

	//reset counters
	n_CSU_cycles = 0;
	scanPath_len = 0;

	//free allocated memory using the (new) memory allocation method
	free_memory();		//if this method is not called, then another SCT, with another (new) vectors will be called , while previously created SCT in heap using the (new) operation is not destroyed yet; this is because if we have a loop on all NW_TDRs and we wish to create an SCT for each target_reg, then we have to free the memort of that TDR's SCT beside clearing all its used vectors.
}

void node::reset_vectors()
{
	AVs.clear();
	AN.clear();
	AP.clear();
}

void node::reset_counters()
{
	n_CSU_cycles = 0;
	scanPath_len = 0;
	std::vector<vector<string>>().swap(n_tracedNodes);
}

void node::delete_vectors()
{
	/*
	https://www.techiedelight.com/delete-vector-free-memory-cpp/
	If you want to reset you vector back to a empty state then we can use the swap trick to swap the contents of the vector into a temporary that will get destroyed and free the memory
	This will create a temporary empty vector, swap it with the one you have so now it is empty and then destroy everything in the temporary vector.
	//std::vector<string>().swap(NW_SCT_to_SAT_clauses);
	OR
	NW_SCT_to_SAT_clauses.clear();
	NW_SCT_to_SAT_clauses.shrink_to_fit();
	*/

	//Because in (reset_vectors()) they were only cleared!!
	std::vector<reg>().swap(AVs);
	std::vector<node_address>().swap(AN);
	std::vector<node_address>().swap(AP);
	std::vector<node_address>().swap(VN);
	std::vector<node_address>().swap(CN);
	std::vector<SDGnode_address>().swap(SDG_AP);
	std::vector<SDGnode_address>().swap(SDG_VN);
	
	// next section should be loaded only "once" for the whole network
	std::vector<reg>().swap(NW_SCBs);
	std::vector<string>().swap(NW_TDRs);
	std::vector<selection>().swap(main_sel_clauses);
	std::vector<connection>().swap(SDG_con_clauses);
	std::vector<NWElement_statistics>().swap(target_registers);

	std::vector<vector<reg>>().swap(AVs_total);
	std::vector<vector<reg>>().swap(AVs_sorted);
	vector<vector<string>>().swap(n_tracedNodes);
}

bool node::operator== (const node& x)
{
	if ((this->reg_id == x.reg_id))
		return true;
	else
		return false; //before doing the return, call the destructor to destroy (x node)
}

int node::check_id_existence(vector<node_address> &p, const string& reg_id)
{
	int pos = find(p.begin(), p.end(), reg_id) - p.begin(); //here the comparison is based upon the 'reg_id' ONLY where the 'operator==' inside "node_address" struct is used, and this is the default scenario
	//here If I want to compare 'reg_id' only
	{
		if (pos < p.size())
			return pos;
		else//here if a node with this 'reg_id' doesn't even exist.
			return -1;
	}
}

int node::check_node_existence(vector<node_address> &p, const node &x)
{
	int pos = find(p.begin(), p.end(), x.reg_id) - p.begin(); //here the comparison is based upon the 'reg_id' ONLY where the 'operator==' inside "node_address" struct is used, and this is the default scenario
	if ((pos < p.size()) && (x.sat_value == p[pos].address->sat_value))
		return pos; //means there exist a node with the same 'reg_id' and 'sat_value'
	else if (pos < p.size())
		return -2; //means there exist a node with the same 'reg_id' but with different 'sat_value'
	else //here if the passed node with this 'reg_id' doesn't even exist.
		return -1;
}

int node::check_SDGnode_existence(vector<SDGnode_address> & p, const string& reg_id)
{
	//I'm only interested to check for the existence of 'reg_id' value inside the passed vector

	int pos = find(p.begin(), p.end(), reg_id) - p.begin();
	if (pos < p.size())
		return pos;
	else
		return -1;
}

int node::check_reg_existence(vector<reg> & p, const string& reg_id)
{
	reg temp{ reg_id , 0, 0 };
	int pos = find(p.begin(), p.end(), temp) - p.begin();
	if (pos < p.size())
		return pos;
	else
		return -1;
}

void node::generate_unVisitedNodes_SCT() //this method to include other non-visited registers (TDRs or SCBs) which are part of the whole NW tree, but aren't part of the target register tree
{
	for (size_t i = 0, e = main_sel_clauses.size(); i < e; i++) //here some OPTIMIZATIONs could be done, by using a vector 'main_sel_clauses' instead of a pointer to array and whenever any clause is traversed, we remove its corresponding clause from the vector meaning that we already finished with this clause, this will speed up the searching (for loop) mechanism a lot.
	{
		if (!is_SCB_SIB(main_sel_clauses[i].reg_id)) //This condition is NOT required but we add it in order to speed up the tree generation for Non-Visited nodes and make it limited to only the reg TDRs (which include structrual or temporal dependency with other SCBs/SIBs in the network, so Non-Visited SCBs/SIBs will be covered anyway.
		{
			//here I have to create "newNodes" in heap using the "new" operator, and not in stack by typing "node temp(main_sel_clauses[i].reg_id, 0, 0)" in order to keep these nodes saved in memory as long as we traverse over them and not being destructed once the function is finished 
			if (check_id_existence(VN, main_sel_clauses[i].reg_id) == -1)//false means check only for the Matching in 'reg_id'
			{
				node* newNode = new node(main_sel_clauses[i].reg_id, 0, -1); //here I'm not interested with the 'state' and 'sat_value', I'm only interested with the (Active/Satisfied) characteristic of each node which could be deduced by examining the 'sat_value' of SCBs/SIBs nodes (which have been set correctly through the tree generation process of each Reg).

				VN.emplace_back(newNode->reg_id, newNode);
				generate_SCT(*newNode); //to adjust the children nodes of this node, so that 'is_active' can do the check correctly 
										//this have to be 'generate_tree' ALWAYS and not 'generate_tree_withConflictChecking'; because I don't have to check for conflict while generating the Active scan path by examining other nodes
			}
		}
	}

	//As a check 'VN.size()' should be equal to 'n_NWElements' to insure that all elements in the network are visited/examined
	//However, there may exist in the network some scan segments, that is not a scan register, i.e. doesn't act as a selection control for other NW's multiplexers and hence not exist in NW_TDRs' registers_selctions, so, we need to include them also in network scan segments (VN).
	if (VN.size() < main_sel_clauses.size())
	{
		for (size_t i = 0, e = main_sel_clauses.size(); i < e; i++) //this section for scan segments that don't exist in other NW Registers_Selections.
		{
			if (check_id_existence(VN, main_sel_clauses[i].reg_id) == -1)
			{
				node* newNode = new node(main_sel_clauses[i].reg_id, 0, -1);

				VN.emplace_back(newNode->reg_id, newNode);
				generate_SCT(*newNode);

				if (VN.size() == main_sel_clauses.size()) //recheck each time to stop looping if all NW elements have been traversed
					break;
			}
		}
	}

	generate_AP(); //check the activity and satisfy attrs of each node in the network to generate the AP
}

void node::print_AP()
{
	//std::sort(AP.begin(), AP.end(), doj::alphanum_less<std::string>()); //in ascending order

	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		int pos = check_reg_existence(NW_SCBs, AP[i].reg_id);
		if (pos != -1)
		{
			cout << AP[i].reg_id << ": ";
			for (int j = AP[i].address->length - 1; j >= 0; j--)//FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
			{
				cout << ((NW_SCBs[pos].state >> j) & 1);
			}
			cout << ", ";
		}
		else //for TDR access print 'XXX'
		{
			cout << AP[i].reg_id << ": " << "X, ";
		}
	}
	cout << "\n\n";
}

node& node::operator= (const node& other) //https://www.youtube.com/watch?v=7LxepUEcXA4 // pass by reference always better than pass by value in performance because the pass-by-value parameter serves as a temporary (where it calls copy constructor internally to create a local object copied from the passed by value parameter) 
{
	//in equal assignment both nodes have same (deph, sat_value), which not the case in copy_subTree, where I usually have different values for (depth, sat_value)
	node(other, other.depth, other.sat_value);
	return *this;
}

void node::satisfy_node()
{
	target_registers.back().retargeting_vectors.emplace_back(AN);
	update_SCBStates();					//(1) update network state: update SCBState with the new satisfing values
	update_nodes_states(*rootptr);		//(2) upate nodes' state after each CSU cycle: Active, satisfiable, ...
	reset_vectors();					//(3) reset vectors (like AVs, AP) for the new tree traversal 
}

void node::check_conflict(node& x) //used to check the conflict between any node and root's visited children
{
	//in this method, I'm only interested with the root's first level children, where even if one child of the next levels becomes unsatisfed (because of conflict) it doesn't matter anymore because I already satsfied the parent, and this is what I'm interesred in and not the children. 

	unsigned int i;
	int pos = check_node_existence(CN, x); //check for the similarity in (id, 'sat_value')

	for (i = 0; i < noOfRootVChildren; i++)
	{
		if ((rootptr->ptrToChildren[i]->reg_id == x.reg_id))
		{
			if (((*(*rootptr).ptrToChildren[i]).sat_value != x.sat_value) && ((pos == -1) || (pos == -2))) //(-1) means the node doesn't exist originally, however (-2) means a node with the same 'reg_id' but different 'sat_value' does exist, we could say 'if (pos < 0)' instead. Both cases indicate that a node with exact circumference doesn't exist previously in CT, so we need to push this conflicted node
			{
				node* temp = new node(x.reg_id, 0, x.sat_value);

				CN.emplace_back(temp->reg_id, temp); //CT could carry multiple nodes with the same'reg_id' but each has a different 'sat_value' (i.e. 'sat_value' is an int variable which could carry decimal values (not boolean) like SREG, because of that I may have [(SREG_1, 1), (SREG_1, 3), (SREG_1, 5)]
				break;
			}
			else if (((*rootptr->ptrToChildren[i]).sat_value == x.sat_value) && (pos == -2))//this is required to be used as a CT reset, whenever a new node is visited but with the same root's child 'sat_value', then conflict no more exist, and if there were a node in CT with the same 'reg_id' had cause a conflict before, we need to remove it because the conflict has been resolved now by this new node(x)
			{
				pos = check_id_existence(CN, x.reg_id); //here I'm disabling the 'sat_value' checking, because (pos =-2) means a node with same 'reg_id' does exist in CT, so to return were its exactly we need to disable the 'sat_value' checking and check for only 'reg_id' value.
				CN.erase(CN.begin() + pos); //remove the node which trigger the conflict flag, because this node (x) had removed the conflict situation by resatisfying the root children without any need to sort the tree.
				break;
			}
			break;//This is if one of root's children is equal to x.reg_id but both have the same 'sat_vaue' and (pos == -1) meaning this node doesn't exist primarily in CT vector, so no conflict and the node wasn't cause of any FORMERLY conflict, then break directly indicating No Conflict here 
		}
	}
}

void node::sort_tree(node &x)
{
	if (x.ptrToChildren == NULL)
	{
		x.weight = 1;
		return;
	}
	//Doing this will cause the sorting to start from the leaf children up to the root node
	for (int i = 0; i < x.noOfChildren; i++)
	{
		sort_tree(*x.ptrToChildren[i]);
	}

	//(1) after checking all the leaf children weights, sort them
	for (int i = 0; i < x.noOfChildren - 1; i++)
	{
		for (int j = i + 1; j < x.noOfChildren; j++)
		{
			if ((*x.ptrToChildren[i]).weight < (*x.ptrToChildren[j]).weight)
			{
				int pos1 = check_id_existence(VN, x.ptrToChildren[i]->reg_id);
				int pos2 = check_id_existence(VN, x.ptrToChildren[j]->reg_id);
				int pos3 = check_id_existence(AP, x.ptrToChildren[i]->reg_id);
				int pos4 = check_id_existence(AP, x.ptrToChildren[j]->reg_id);

				node temp;
				temp = *x.ptrToChildren[i];
				*x.ptrToChildren[i] = *x.ptrToChildren[j];
				*x.ptrToChildren[j] = temp;

				//This section to update the nodes addresses after each swapping action
				//Because of the sorting action, now "VN" and "AP" vectors are corrupted where the elements' address member aren't more pointing to the correct address, where nodes addresses have been swapped while sorting the tree, so we need to update it
				VN[pos1].address = x.ptrToChildren[j];
				VN[pos2].address = x.ptrToChildren[i];
				if (pos3 != -1)// here we need to check if the swapped node belongs to the A.S.P or not, in contrast to VN, where any element should belong to it
					AP[pos3].address = x.ptrToChildren[j];
				if (pos4 != -1)
					AP[pos4].address = x.ptrToChildren[i];

			}
		}
	}

	//(2) Then update the weight of the parent node with the weight of the longest branch (first one) + 1
	x.weight = (*x.ptrToChildren[0]).weight + 1;
	return;
}

void node::MPO_DFS_conflict_resolution()
{
	sort_tree(*rootptr);
}

bool node::is_SCB_SIB(string& x)
{
	for (int i = 0; i < (sizeof(SCB_SIB) / sizeof(string)); i++)
	{
		if (x.find(SCB_SIB[i]) != std::string::npos)
			return true;
	}

	return false;
}

unsigned int node::Inst_AccessTime()
{
	//return (scanPath_len + (n_CSU_cycles * 4));
	return (scanPath_len + (n_CSU_cycles * 2)); //because the multiplier(*2) is used in SAT cost function
}

size_t node::get_selection_clause_index(const string& reg_id)
{
	size_t index, e = main_sel_clauses.size();

	for (index = 0; index < e; index++)
	{
		if (reg_id == main_sel_clauses[index].reg_id)
			return index;
	}
	if (index == e) //means there is a broken here, a reg not exist in the input selection array
	{
		cout << "ERROR: Reg: (" << reg_id << ") doesn't exist in network_selection clauses!!";
		exit(EXIT_FAILURE);

		return -1; //invalid index
	}
}

unsigned int node::get_SCT_size(node& x)
{
	unsigned int n_nodes = 0;
	if (x.noOfChildren != 0)
	{
		n_nodes += x.noOfChildren;

		for (size_t i = 0; i < x.noOfChildren; i++)
			n_nodes += get_SCT_size(*x.ptrToChildren[i]);
	}
	return n_nodes;
}

void node::apply_retargeting(bool method_of_retargeting, bool write_read, const string& output_file)
{
	void (node::*pointerToFn)(node &x); //this pointer is used to assign the address of a Fn to a pointer (or we can say assign function to variable), also this is a member pointer (A member pointer is a different type category from a ordinary pointer. The member pointer will have to be used together with an object of its class)

	if (method_of_retargeting == true)
	{
		cout << "Using MDFS: \n";
		if (write_read == true)
			pointerToFn = &node::MDFS_writeModel;
		else
			pointerToFn = &node::MDFS;
	}
	else
	{
		cout << "Using MPO_DFS: \n";
		if (write_read == true)
			pointerToFn = &node::MPO_DFS_writeModel;
		else
			pointerToFn = &node::MPO_DFS;
	}

	initialize_NW();
	auto start = std::chrono::steady_clock::now();
	(*rootptr.*pointerToFn)(*rootptr); //(object.*pointer_name)(arguments);
	auto stop = std::chrono::steady_clock::now();

	generate_output_retargeting_vectors();
	print_output_retargeting_vectors(output_file);

	unsigned int accessTime = Inst_AccessTime();//Access time (CC)
	std::chrono::duration<double> execution_time = stop - start;
	//float ms = execution_time.count() * 1000.0f;

	//"update" NW_TDRs[i] record with just measured statistics if it is exist, otherwise create a new one if it is not.
	if (target_registers.back().n_CSU_cycles == 0) //means there is already a record for that TDR and I need only to update it with its assoicated measurements. 
		target_registers.back().update_record(n_CSU_cycles, accessTime, execution_time.count(), get_SCT_size(*rootptr) + 1, method_of_retargeting, n_tracedNodes); //get_SCT_size(*rootptr) + 1: (+1) to include also the (*rootptr) node/ target register

	else //means there exist a record with same id (NW_TDRs[i].reg_id) and it is also updated before, however I may need to insert a new one with (same id but different structured_retargeting_method), like inserting "two statistics for same target_reg" but one for MDFS readings and the other for MPO_DFS readings. 
		target_registers.emplace_back(target_registers.back().reg_id, n_CSU_cycles, accessTime, execution_time.count(), get_SCT_size(*rootptr) + 1, method_of_retargeting, n_tracedNodes);
}

void node::apply_retargeting_withConflictChecking(bool method_of_retargeting, const string& output_file)
{
	//has the advatage of enhanced retargeting by sorting first generated SCTs
	//it uses (generate_SCT_withConflictChecking, initialize_NW_withConflictChecking, MPO_DFS_conflict_resolution)

	void (node::*pointerToFn)(node &x); //this pointer is used to assign the address of a Fn to a pointer (or we can say assign function to variable), also this is a member pointer (A member pointer is a different type category from a ordinary pointer. The member pointer will have to be used together with an object of its class)

	if (method_of_retargeting == true)
		pointerToFn = &node::MDFS;
	else
	{
		if (!CN.empty()) //if there were any conflict while generating the tree using 'generate_tree_withConflictChecking' , then I need to sort the tree before applying the 'MPO_DFS'
		{
			cout << "Using MPO_DFS with Tree Sorting technique: \n";
			MPO_DFS_conflict_resolution();
			pointerToFn = &node::MPO_DFS;  //MPO_DFS(*node::rootptr);
		}
		else
			pointerToFn = &node::MPO_DFS;
	}

	initialize_NW_withConflictChecking();
	auto start = std::chrono::steady_clock::now();
	(*rootptr.*pointerToFn)(*rootptr); //(object.*pointer_name)(arguments);
	auto stop = std::chrono::steady_clock::now();

	generate_output_retargeting_vectors();
	print_output_retargeting_vectors(output_file);

	unsigned int accessTime = Inst_AccessTime();//Access time (CC)
	std::chrono::duration<double> execution_time = stop - start;
	//float ms = execution_time.count() * 1000.0f;

	//"update" target_register record with just measured statistics
	target_registers.back().update_record(n_CSU_cycles, accessTime, execution_time.count(), get_SCT_size(*rootptr) + 1, method_of_retargeting, n_tracedNodes); //get_SCT_size(*rootptr) + 1: (+1) to include also the (*rootptr) node
}

void node::test_NW(unsigned int method_of_retargeting, const string& path, const string& initial_state, bool write_read, bool retarget_all_TDRs)
{
	//set (NW_state) and (target_reg)
	//First, I have to adjust vectors' capacity for better performance.
	//Second, I need to load selction clauses, NW_SDG connections and target_reg/NW_TDRs.
	//Third, I need to apply the structured retargeting according to the passed "type" (MDFS or MPO_DFS).  
	unsigned int no_targetRegisters;
	NW_state = initial_state;

	//load inputs(main_sel_clauses, SDG_con_clauses, NW_SCBs) only "once" for the all NW_TDRs tarversal
	load_NW(path + "NW_clauses.txt", path + "NW_smv.pdl", path + "NW_SDG.txt", retarget_all_TDRs);
	load_initial_NWstate();				//this method have to be called first before update_nodes() and print_AP(); in order to set the node's active and satisfy attributes correctly (the calling order is important)
	reserve_vectors_memory();

	//check If I want to gather statistics for the all NW TDRs or for only a specific target_reg_id 
	if (retarget_all_TDRs)
	{
		no_targetRegisters = NW_TDRs.size();
		target_registers.reserve(no_targetRegisters);
	}
	else
		no_targetRegisters = 1;	//apply structured retargeting on an only "one" specific "Target_reg"

	for (unsigned int i = 0; i < no_targetRegisters; i++)
	{
		if (no_targetRegisters > 1)
			target_registers.emplace_back(NW_TDRs[i]);
		else
			load_input_files(path + "NW_smv.pdl", smv_pdl); //this is to load the target register from the pdl file.

		if (method_of_retargeting == 3) //apply structured retargeting two times, one using the MDFS retargeting and the other using MPO_DFS retargeting, so I need to call the same method "apply_retargeting" two times but with different passing parameter "structuring_method"
		{
			apply_retargeting(true, write_read, path + "StructuredRetargeting_output.txt"); //true: MDFS
			//sort_AVs_and_validate_model(); //if the output wasn't valid, an error will be thrown, and the program should be terminated.
			print_NWstatistics(true, i);
			clear_vectors(); //clear all vectors and not reset/free their memory, to let theses vectors to be used later with other TDRs.

			apply_retargeting(false, write_read, path + "StructuredRetargeting_output.txt");//false: MPO_DFS
			//sort_AVs_and_validate_model(); 
			print_NWstatistics(true, NW_TDRs.size() - 1); //NW_TDRs.size() - 1: the one "just inserted" using the other (retargeting_method). (-1) since index always starts from(0).
			clear_vectors();
		}
		else
		{
			bool retargeting_method = (method_of_retargeting == 1) ? true : false; //here (method_of_retargeting) should be either equal to (1) for MDFS retargeting or equal to (2) for MPO_DFS retargeting, where (3) option has been already excluded using the if condition (method_of_retargeting == 3).
			apply_retargeting(retargeting_method, write_read, path + "StructuredRetargeting_output.txt");
			//sort_AVs_and_validate_model(); 
			print_NWstatistics(true, i);
			clear_vectors();
		}
		
		//load_initial_NWstate(); we call this in case the wants to start each retargeting from the user-predefined initial state, like reset state.
		set_current_NWstate(); //this is to set the resulting network state as the current network state.
	}

	print_NWstatistics(false);

	//By the end I need to free all allocated memory
	reset_system();
}

void node::print_NWstatistics(bool target_statistics, unsigned int index)
{
	//statistics for specific "target_reg"
	if (target_statistics)
	{
		cout << "\n//////////////////////////////////////////////////////////////////";
		//SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		cout << "\n*******For " << target_registers[index].reg_id << ": *******\n";
		cout << "\nNumber of Network Elements = " << main_sel_clauses.size();// << ", Check of all_visited_flag = " << ((main_sel_clauses.size() == VN.size()) ? "Satisfied" : "Not Satisfied");
		cout << "\nNumber of TDR's = " << NW_TDRs.size();
		cout << "\nSCT size = " << target_registers[index].SCT_size;
		cout << "\nNumber of CSU cycles = " << target_registers[index].n_CSU_cycles;
		cout << "\nInstrument Access Time = " << target_registers[index].AccessTime;
		cout << "\nRetargeting took " << target_registers[index].execution_time << " s";
		cout << "\nNumber of Traced Nodes: " << get_n_tracednodes_per_TReg(index) << "\n"; //this will return the number of traced nodes in all CSUs; because (avg=sum) since avg=sum/1; (1) because I have only one TDR, the one mentioned in the (smv) file 
		/*for (size_t i = 0, e1 = target_registers[index].n_tracedNodes.size(); i < e1; i++)
		{
			cout << "access no.(" << i + 1 << ") =  " << target_registers[index].n_tracedNodes[i].size() << " :[ ";
			for (size_t j = 0, e2 = target_registers[index].n_tracedNodes[i].size(); j < e2; j++) //because one more row will be inserted to the end of the vector after the last satisfying step in MDFS/MPO_DFS, which hold nothing so it could be ignored
			{
				cout << target_registers[index].n_tracedNodes[i][j] << ", ";
			}
			cout << "]\n";
		}
		*/
		//SetConsoleTextAttribute(hStdout, 15);
		cout << "\n\n//////////////////////////////////////////////////////////////////\n";
	}

	//statistics for the "whole" NW	
	else
	{
		cout << "\n//////////////////////////////////////////////////////////////////";
		//SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);

		cout << "\nNumber of Network Elements = " << main_sel_clauses.size();// << ", Check of all_visited_flag = " << ((n_NWElements == VN.size()) ? "Satisfied" : "Not Satisfied");
		cout << "\nNumber of TDR's = " << NW_TDRs.size();
		cout << "\nSCT size = \n" << "\tAvg = " << get_avg('S') << ", Max = " << get_max('S');
		cout << "\nFor #Traced nodes NW parameter:\n" << "\tAvg= " << get_avg('T') << ", Max=" << get_max('T');
		cout << "\nFor #CSU / access NW parameter:\n" << "\tAvg= " << get_avg('C') << ", Max=" << get_max('C');
		cout << "\nFor Access time(CC) NW parameter:\n" << "\tAvg= " << get_avg('A') << ", Max=" << get_max('A');
		cout << "\nFor Execution time(sec) NW parameter:\n" << "\tAvg= " << get_avg('E') << ", Max=" << get_max('E');

		//SetConsoleTextAttribute(hStdout, 15);
		cout << "\n//////////////////////////////////////////////////////////////////\n";
	}
}

double node::get_avg(char x) //A->access time, C->CSU cycles, E->execution time
{
	double sum = 0;

	switch (x) {
	case 'A':
	{
		for (size_t i = 0, e = target_registers.size(); i < e; i++)
		{
			sum += target_registers[i].AccessTime;
		}
		return (sum / (unsigned int)target_registers.size());
		break;
	}
	case 'C':
	{
		for (size_t i = 0, e = target_registers.size(); i < e; i++)
		{
			sum += target_registers[i].n_CSU_cycles;
		}
		return (sum / (unsigned int)target_registers.size());
		break;
	}
	case 'E':
	{
		for (size_t i = 0, e = target_registers.size(); i < e; i++)
		{
			sum += target_registers[i].execution_time;
		}
		return (sum / (unsigned int)target_registers.size());
		break;
	}
	case 'T':
	{
		unsigned int n_tracednodes_per_TReg;
		for (unsigned int index = 0, e = target_registers.size(); index < e; index++)
		{
			sum += get_n_tracednodes_per_TReg(index);
		}
		return (sum / (unsigned int)target_registers.size());
		break;
	}
	case 'S':
	{
		for (size_t i = 0, e1 = target_registers.size(); i < e1; i++)
		{
			sum += target_registers[i].SCT_size;
		}
		return (sum / (unsigned int)target_registers.size());
		break;
	}
	default: std::cout << "Passed parameter isn't valid!!"; // no error
		return -1;
		break;
	}
}

double node::get_max(char x)
{
	switch (x) {
	case 'A':
	{
		double max = target_registers[0].AccessTime;
		for (size_t i = 1, e = target_registers.size(); i < e; i++)
		{
			if (max < target_registers[i].AccessTime)
				max = target_registers[i].AccessTime;
		}
		return max;
		break;
	}
	case 'C':
	{
		double max = target_registers[0].n_CSU_cycles;
		for (size_t i = 1, e = target_registers.size(); i < e; i++)
		{
			if (max < target_registers[i].n_CSU_cycles)
				max = target_registers[i].n_CSU_cycles;
		}
		return max;
		break;
	}
	case 'E':
	{
		double max = target_registers[0].execution_time;
		for (size_t i = 1, e = target_registers.size(); i < e; i++)
		{
			if (max < target_registers[i].execution_time)
				max = target_registers[i].execution_time;
		}
		return max;
		break;
	}
	case 'T':
	{
		unsigned int n_tracednodes_per_TReg = get_n_tracednodes_per_TReg(0);
		double max = n_tracednodes_per_TReg;
		for (unsigned int index = 1, e = target_registers.size(); index < e; index++) //here i start from (1) where max value has been set initially using the value at (i=0)
		{
			n_tracednodes_per_TReg = get_n_tracednodes_per_TReg(index);

			if (max < n_tracednodes_per_TReg)
				max = n_tracednodes_per_TReg;
		}
		return max;
		break;
	}
	case 'S':
	{
		double max = target_registers[0].SCT_size;
		for (size_t i = 1, e = target_registers.size(); i < e; i++)
		{
			if (max < target_registers[i].SCT_size)
				max = target_registers[i].SCT_size;
		}
		return max;
		break;
	}
	default: std::cout << "Passed parameter isn't valid!!"; // no error
		return -1;
		break;
	}
}

unsigned int node::get_n_tracednodes_per_TReg(unsigned int TDR_index)
{
	unsigned int n_tracednodes_per_TReg = 0;
	for (size_t j = 0, e1 = target_registers[TDR_index].n_tracedNodes.size(); j < e1; j++)
		n_tracednodes_per_TReg += target_registers[TDR_index].n_tracedNodes[j].size();

	return n_tracednodes_per_TReg;
}

void node::adjust_scanPath_len()
{
	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		scanPath_len += AP[i].address->length;
	}
}

void node::build_SDG(SDG_node &x)
{

	//SDG_con_clauses.size() != n_NWElements, where I have new different nodes for the SDG like (TDI, TDO, BR, SIB_SI, SIB_SO, I0_M1, ...)
	for (size_t i = 0, e1 = SDG_con_clauses.size(); i < e1; i++)
	{
		//Always insert nodes at the end
		if (x.reg_id == SDG_con_clauses[i].reg_id)
		{
			x.selection_control = SDG_con_clauses[i].selection_control;
			x.length = SDG_con_clauses[i].length;
			x.state = -1; //this is only an initial value, but it will be re-adujsted later to the correct state while invoking the setSCBStates() method. (-1) <--> uninitialized state

			vector <string> temp = SDG_con_clauses[i].next_OrderedNodes;
			//SDG_con_clauses.erase(SDG_con_clauses.begin() + i); //remove that element to speed up the search, (Not sure) because this vector resizing and elements resorting should also take time and it could be more than the searching/for loop above!!

			if (temp.size() != 0) //of if(x.reg_id != 'TDI')
			{
				for (size_t j = 0, e2 = temp.size(); j < e2; j++)
				{
					int pos = check_SDGnode_existence(SDG_VN, temp[j]);
					if (pos == -1)
					{
						x.next.emplace_back(new SDG_node{ temp[j] , "", 0, 0,{},{} });
						//this is to adjust the prev pointer of the next SDG nodes
						x.next[j]->prev.emplace_back(&x);//this can be adjusted also while creating the object by passing the correct values to the constructor "(new SDG_node{ temp[j] , "", 0, 0,{},{&x} });", here we did the same but through a push_back() command.

						SDG_VN.emplace_back(temp[j], x.next[j]);
						build_SDG(*x.next[j]);
					}
					else
					{
						x.next.emplace_back(SDG_VN[pos].address);
						(*SDG_VN[pos].address).prev.emplace_back(&x);
					}
				}
			}
			else
				x.next = {};

			if ((&x != head) || ((&x == head) && (SDG_VN.size() == SDG_con_clauses.size())))
				return; //to stop the for loop if (if (x.reg_id == SDG_con_clauses[i].reg_id)) is reached
		}
	}
	if (SDG_VN.size() < SDG_con_clauses.size()) //I have a return statement, so I will not reach here except if I processed all the "SDG_con_clauses" connection array, and if after that this condition is TRUE, then it means that there is a broken in NW connectivity here, a reg not exist in the input connection array
	{
		cout << "ERROR: Reg: (" << x.reg_id << ") doesn't exist in network_connection array!!";
		exit(EXIT_FAILURE);
	}
	/*
	//print the resultant SDG
	if(&x == head) ////means this is the 'TDO' node
		printSDG(x);
	*/
}

void node::generate_SDG_AP(SDG_node &x)
{
	SDG_AP.emplace_back(x.reg_id, &x);

	if (x.next.size() > 1) //then this is a SCB_SIB[] and I need to check the selection control signal to move into the correct path
	{
		int pos = check_reg_existence(NW_SCBs, x.selection_control);
		if (pos != -1)
		{
			int selectionControl_value = NW_SCBs[pos].state;
			generate_SDG_AP(*x.next[selectionControl_value]); //Depending on that the next nodes are inserted in sorted way in the main function, so that their order in the next vector would be consistant with the selection control (i.e. if SREG=2 that's mean this is the third selection element in the next vector)
		}
	}
	else if (x.next.size() == 1)
	{
		generate_SDG_AP(*x.next[0]);
	}
	else //(x.next.size() == 0 || x.reg_id == "TDI")
	{
		return;
	}
}

void node::sort_AVs_and_validate_model()
{
	if (SDG_con_clauses.size() != 0) //means there exist a NW SDG connection input_file for this network, because it is possible to be not available.
	{
		head = new SDG_node({ "TDO", // reg_id
		"", //selection_control
		0, //state
		0, //length
		{}, //vector <SDG_node*> next
		{} }); //vector <SDG_node*> prev}); //head pointer hold the address of 'TDO' node

		SDG_VN.emplace_back(head->reg_id, head);

		//1- set SDG nodes clauses to be uesd later in building the SDG, which is already done while invoking the "initialize_NW" method

		//2- build SDG
		build_SDG(*head);

		//check that the unrequired SCBs are reseted (only the required ones through the A.S.P are setted)
		//3- set SCB states according to network state
		load_initial_NWstate();

		//4- Generate A.S.P from SDG and check if the generated AVs could be accessed through it or not
		generate_SDG_AP(*head);

		string reg_id;

		for (size_t i = 0, e = AVs_total.size(); i < e; i++)
		{
			AVs_sorted.emplace_back(); //AVs_sorted is a two dimensional vector, so every new loop I need to push an empty row, so it can be accessed and initialized (set) through the loop

			//check if all AVs_total[i][j] are accessable through the A.S.P, but here the check is done in opposite way (check that SDG_AP covers ALL the elements in AVs_total[i]) and this is to do the sort through the same step (using the same for loop)
			for (int n = SDG_AP.size() - 1; n >= 0; n--) //to generate the path from TDI to TDO and not the opposite like in SDG
			{
				reg_id = SDG_AP[n].reg_id;
				int pos = check_reg_existence(AVs_total[i], reg_id); //not the opposite "check_existence(&SDG_AP, AVs_total[i])" , and this is to push items into "AVs_sorted" based on NW connectivity(SDG) and not based on "AVs_total" order
				if (pos != -1)
					AVs_sorted[i].emplace_back(AVs_total[i][pos]);
			}
			if (AVs_sorted[i].size() != AVs_total[i].size()) //there are only two possibilities (= or <), if (<) that's mean that Structured Retargeting technique is wrong where its trying to access unreachable reg..
			{
				//throw an ERROR!!
				throw "ERROR: Structured Retargeting is trying to access UN-REACHABLE register !!";
			}

			SDG_AP.clear();

			//5- update the SCBStates vector in order to generate the new A.S.P from the SDG, and then complete checking the remaining AVs_total array of vectors
			update_SCBStates(AVs_total[i]);
			generate_SDG_AP(*head);
		}

		//SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
		//6- if all AVs_total[i] are accessable each in the corresponding cycle, then check that the target_reg is accessable by the end of retargeting
		if (check_SDGnode_existence(SDG_AP, target_registers.back().reg_id) != -1)
			cout << "Retargeting for (" << target_registers.back().reg_id << ") was done CORRECTLY :)\n";

		//7- print sorted AVs
		print_AVs_sorted();
	}
	else
		cout << "Please enter the NW_SDG connection file First!!\n";

}

void node::print_AVs_sorted()
{
	//SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	cout << "Sorted AVs: \n";
	//SetConsoleTextAttribute(hStdout, 15);

	for (size_t i = 0, e1 = AVs_sorted.size(); i < e1; i++)
	{
		cout << "{ ";
		for (size_t j = 0, e2 = AVs_sorted[i].size(); j < e2; j++)
		{
			cout << AVs_sorted[i][j].reg_id << ": " << AVs_sorted[i][j].state << ", ";;
		}
		cout << "}\n";
	}
}

void node::load_input_files(const string& input_file, input_file_type option)
{
https://stackoverflow.com/questions/50188898/c-reading-data-from-a-txt-file-to-vector-of-struct

	std::ifstream data_file(input_file.c_str());
	string line;


	unsigned int no_scan_segments;
	string no_SCBs, no_TDRs; //no_scan_segments = #SCBs + #TDRs, no_SCBs = #SCBs, no_TDRs = #TDRs.

	if (!data_file)
		printf("Cannot open the File : %s\n", input_file.c_str());

	else
	{
		switch (option)
		{
		case Selection_clauses:
		{
			//The first two lines in the input file carry the number of Network Scan Registers and Network TDRs.
			getline(data_file, no_SCBs);	//#SCBs or #SIBs
			getline(data_file, no_TDRs); //#TDRs
			no_scan_segments = stoi(no_SCBs) + stoi(no_TDRs);

			main_sel_clauses.reserve(no_scan_segments); //where we've selection clauses for NW_SCBs and NW_TDRs
			NW_SCBs.reserve(stoi(no_SCBs));
			NW_TDRs.reserve(stoi(no_TDRs));

			string reg_id, selectionClause, reg_len;
			unsigned int reset_val, itr; //char_iterator

			while (getline(data_file, line))
			{
				if (line.length() != 0)
				{
					reg_id = "";
					selectionClause = "";
					reg_len = "";
					reset_val = 0;
					itr = 0;

					while (line[itr] != '"')
						itr++;
					while (line[++itr] != '"')
						reg_id += line[itr];

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
						selectionClause += line[itr];

					while (!isdigit(line[itr]))
						itr++;

					while (isdigit(line[itr]))
						reg_len += line[itr++]; //reg length could be more than (1 char) like (20)

					while (!isdigit(line[itr]))
						itr++;
					reset_val = line[itr] - '0';


					main_sel_clauses.emplace_back(reg_id, selectionClause, stoi(reg_len), reset_val);

					if (is_SCB_SIB(reg_id))
					{
						if (check_reg_existence(NW_SCBs, reg_id) == -1)
							NW_SCBs.emplace_back(reg_id, -1, stoi(reg_len));
					}
					else
						NW_TDRs.emplace_back(reg_id);
				}
			}
			break;
		}
		case smv_pdl:
		{
			string target_reg;
			getline(data_file, line);

			if (line.length() != 0)
			{
				unsigned int itr = 0;
				target_reg = "";

				while (line[itr] != ' ')
					itr++;

				while (line[++itr] != ' ')
					target_reg += line[itr];

				target_registers.emplace_back(target_reg);
			}
			break;
		}
		case SDG_connections:
		{
			no_scan_segments = main_sel_clauses.size();
			SDG_con_clauses.reserve(no_scan_segments * 4);	//(*4) just a number chose by try and error
			SDG_VN.reserve(no_scan_segments * 4);
			SDG_AP.reserve(no_scan_segments * 3);
			AVs_sorted.reserve(max_no_timeFrames);

			string reg_id, reg_len;
			vector<string> next_OrderedNodes;
			string selection_control;
			unsigned int itr;

			while (getline(data_file, line))
			{
				if (line.length() != 0)
				{
					reg_id = "";
					reg_len = "";
					next_OrderedNodes.clear();
					selection_control = "";
					itr = 0;

					while (line[itr] != '"')
						itr++;			//Do Nothing, just increament the iterator
					while (line[++itr] != '"')
						reg_id += line[itr];

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
					{
						next_OrderedNodes.emplace_back();

						//"I0-Mux2-M2_2/30,I1-Mux2-M2_2/33"
						while ((line[itr] != ',') && (line[itr] != '"'))
							next_OrderedNodes.back() += line[itr++];

						if (line[itr] == '"')
							break;
					}

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
						selection_control += line[itr];

					while (!isdigit(line[itr]))
						itr++;
					//*******This section not tested yet!!!!!!!!!!!!*********
					//length = line[itr] - '0'; //we could do this direct only if the length has one char like reset_vaue (0) but what about if the legth was (100)?!
					while (isdigit(line[itr]))
						reg_len += line[itr++]; //reg length could be more than (1 char) like (20)

					SDG_con_clauses.emplace_back(reg_id, next_OrderedNodes, selection_control, stoi(reg_len));
				}
			}
			break;
		}
		}
	}
}


void node::generate_output_retargeting_vectors()
{
	generate_unVisitedNodes_SCT();
	reset_vectors();		//to simulate that we are starting again from NW_initial configuration to generate the output retargeting vectors: this is mainly resultant from that we want to separate the ASPs construction time from the structured retargeting run time.
	//load_initial_NWstate(); we call this in case the wants to start each retargeting from the user-predefined initial state, like reset state.
	load_current_NWstate();
	generate_AP();         //this is to generate the "initial" ASP.
	/*
	cout << "\n//////////////////////////////////////////////////////////////////";
	//SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	cout << "\n*******For " << target_reg << ": *******\n";
	//SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
	cout << "The Active Scan Path is:\n";
	print_AP(); //To print the active scan path before running the structured retargeting
	//SetConsoleTextAttribute(hStdout, 15); //set back to black background and white text
	*/
	for (size_t i = 0, e = target_registers.back().retargeting_vectors.size(); i < e; i++)
	{
		generate_AVs(target_registers.back().retargeting_vectors[i]);
		update_SCBStates(AVs);
		reset_vectors();
		generate_AP();  //this is to generate the ASP of each applied CSU.
	}

	//print_AVs_total();
	//print_AP();		//just to make sure that the target_reg is finally active and included in the ASP.
}

void node::print_output_retargeting_vectors(const string& output_file)
{
	FILE *file;
	string output_text = "";

	if ((file = fopen(output_file.c_str(), "a")) != NULL) //"a" for append or "w" for write.
	{
		output_text += "\n*******Retargeting output vectors For " + target_registers.back().reg_id + ": *******\n";

		for (size_t i = 0, e1 = AVs_total.size(); i < e1; i++)
		{
			output_text += "CSU(" + to_string(i + 1) + "): ";
			for (size_t j = 0, e2 = AVs_total[i].size(); j < e2; j++)
			{
				if (is_SCB_SIB(AVs_total[i][j].reg_id))
					output_text += AVs_total[i][j].reg_id + ": " + to_string(AVs_total[i][j].state) + ", ";	//print decimal value
				else //for TDR access print 'XXX'
					output_text += AVs_total[i][j].reg_id + ": X, ";
			}
			output_text += "\n";
		}

		output_text += "\n//////////////////////////////////////////////////////////////////";

		fprintf(file, "%s", output_text.c_str());
		fclose(file);
	}
	else printf("%s \n", "Unable to open file");
}