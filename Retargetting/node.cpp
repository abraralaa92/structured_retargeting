#include "node.h"
#include "alphanum.hpp"
#include <iostream>
#include <fstream>
#include <algorithm>
#include <windows.h> //for coloring some texts
#define V_TDR "V_TDR"

using namespace std;

//Global variables
string NW_state; //Active Network State
string target_reg;
node* rootptr = NULL; //hold the address of the root node 
unsigned int height;
vector<selection> main_sel_clauses; //hold all the selection clauses of the network's registers
vector<connection> SDG_con_clauses; //hold all the Network connection clauses, this is a vector and not an array like 'selection* main_sel_clauses' beacuse dealing with vectors in this context will be easier and faster 
vector<reg> SCBstate;
vector<node_address> VN; //list of visited nodes, here we don't have to store a vector of nodes(huge data structure to be saved), we need oly the node name and where it saved in heap :)
vector<SDGnode_address> SDG_VN; //list of SDG visited nodes
vector<node_address> AP;//Set of the nodes in the SDG active scan path
vector<SDGnode_address> SDG_AP; //Set of the nodes in the active scan path
vector<node_address> AN;//Set of Active Nodes generated by structural retargeting techniques
vector<reg> AVs;//Set of Variable Length Access Vectors (ordered bit vector constructed from SAN, previously satisfied values and the reset values)
vector<node_address> CN; //list of conflicting nodes
vector<vector<reg>> AVs_total; //AVs of all the required patterns to access a register
vector<vector<reg>> AVs_sorted; //All AVs vectors which are required to access the target but also sorted
vector<vector<reg>> _2D_SCT; //this is a 2 Dimentional vector SCT instead of tree of pointers structure. 
vector<reg> twiceSatisfying_SCBs;

//this section is used to change cout color
CONSOLE_SCREEN_BUFFER_INFO Info;
HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
WORD currentConsoleAttr = Info.wAttributes;

std::chrono::time_point<std::chrono::steady_clock> start, stop;
std::chrono::duration<float> execution_time;

unsigned int noOfRootVChildren;
string SCB_SIB[] = { "SIB","SIBP", "PSIB", "SCB", "SREG", "SR" }; //there are SR: "shift register" like the one used in SIB and SR: "scan register" like the one used in TDRs, here we refer to the one used in SIB(shift register)
string TDR[] = { "R","WI","wrpInput", "wrpOutput", "wrpControl", "ScanChain", "In", "Out", "SC" };
struct SDG_node* head = NULL;

vector<NWElement_statistics> NW_TDRs; //vector of statistics of ALL NW_target registers using structured retargeting 
unsigned int n_CSU_cycles = 0;
unsigned int scanPath_len = 0;
vector <vector<string>> n_tracedNodes;  //traced nodes are the nodes which have structrual or temporal dependencies with the target register

node::node()
{
	reg_id = "";
	selection_clause = "";
	this->depth = 0;
	this->sat_value = -1; //The default is that the node's state value is (unkown) or (uninitialized) until serial bits with real valuse are shifted to the iJtag Network. (-1) <--> (unknown/uninitialized) value
	this->reset = 0;
	this->active = false; //initially all nodes are (inactive, unsatisfied)
	this->satisfied = false;
	this->noOfChildren = 0;
	ptrToChildren = NULL;
	weight = 0;
	length = 0;
}

node::node(string& reg_id, unsigned int depth, int sat_value)
{
	this->reg_id = reg_id;

	size_t index = get_selection_clause_index(reg_id);
	//Vector Assignmnet//
	//So we can see that vector assignment is 55.38% faster than Insert() and  89% faster than push_back(). Caution: Do not use std::vector::swap. std::vector::swap is not copying a vector to another, it is actually swapping elements of two vectors, just as its name suggests. In other words, the source vector to copy from is modified after std::vector::swap is called, which is probably not what you are expected.
	selection_clause = main_sel_clauses[index].selectionClause;
	this->length = main_sel_clauses[index].reg_len;
	this->reset = main_sel_clauses[index].reset_val;
	
	this->depth = depth;
	this->sat_value = sat_value; // root node always not satisfied, for the other nodes 'sat_value' can be inferred from the selection clause
	
	//This is only the initial values, which will be modified while applying different code sections
	this->active = false;
	this->satisfied = false;
	this->weight = 0;

	if (selection_clause == "TRUE" || selection_clause == "true") //it means it is a leaf
	{
		this->noOfChildren = 0;
		this->ptrToChildren = NULL;
	}
	else if (!selection_clause.empty()) //or I can type just "else"
	{
		this->noOfChildren = count(selection_clause.begin(), selection_clause.end(), '^') + 1; //this part is uncomplete yet in case I have 'OR', //I can't use 'sizeof(x.next_nodes)' to find out the size of a dynamic array. The size of an array allocated with new[] is not stored in any way in which it can be accessed. Note that the return type of new [] is not an array - it is a pointer (pointing to the array's first element). So if you need to know a dynamic array's length, you have to store it separately.
		this->ptrToChildren = new node*[this->noOfChildren];
	}

}

node::node(const node& other, unsigned int depth, int sat_value) //Overloaded assignment only invoked if the object already exist! (like x=y), so (node x = y) will call the copy constructor because object x doesn't exist yet.
	:reg_id(other.reg_id), selection_clause(other.selection_clause), depth(depth), sat_value(sat_value), reset(other.reset), weight(other.weight), length(other.length), active(other.active), satisfied(other.satisfied), noOfChildren(other.noOfChildren)
{
	/*
	//This method will be called in TWO scenraios:
	1- in (vector.push_back) while enlarging the vector size at this time this method will be called through the copy constructor and at which "this->ptrToChildren" will be empty and "other" will carry the old vector data in order to be copied to the new vector, or it could be called also in (x.ptrToChildren[n] = *new node(reg_id, x.depth + 1, sat_value)), where x.ptrToChildren[n]-->this->ptrToChildren initally is empty
	2- in assigning operations through (operator =) like in (ptrToChildren[i] = other.ptrToChildren[i]; ) and at which both (*this and other) will hold data
	*/

	noOfChildren = other.noOfChildren;
	if (noOfChildren == 0)
		ptrToChildren = NULL;
	else
	{
		ptrToChildren = new node*[noOfChildren];
		for (int i = 0; i < noOfChildren; i++)
			ptrToChildren[i] = new node(*other.ptrToChildren[i], depth + 1, (*other.ptrToChildren[i]).sat_value); //take care that the depth of the copied nodes will not be the same (as sat_value "here"), so I need to update depth to be equal to (parent_depth + 1)
	}
}

void node::reserve_vectors_memory(unsigned int children_per_SIB, unsigned int hierarchy_level, bool retarget_all_TDRs, bool apply_both_retargeting, bool NW_SDG_file_exist)
{
	unsigned int expected_no_SCBs = 0;
	unsigned int expected_no_TDRs = 0;
	unsigned int expansion = 1;
	unsigned int max_path_length, max_no_timeFrames;

	if ((children_per_SIB != 0) && (hierarchy_level != 0))//means if the number of these values aren't known from the "NW_generator" to be used for initial vectors_capacity predictions, then use some unprecised way for memory reservation.
	{
		for (unsigned int i = 1; i <= hierarchy_level; i++)
			expected_no_SCBs += myPow(children_per_SIB, i);

		expected_no_TDRs = myPow(children_per_SIB, hierarchy_level);
		max_path_length = expected_no_SCBs + expected_no_TDRs;
		max_no_timeFrames = hierarchy_level * 2;
	}
	else
	{
		//Here we chose some fixed value to use in vectors' memory reservation
		unsigned int reservation_amount = 50;
		expected_no_SCBs = reservation_amount;
		expected_no_TDRs = reservation_amount / 2;
		max_path_length = expected_no_SCBs + expected_no_TDRs;
		max_no_timeFrames = reservation_amount;
	}

	SCBstate.reserve(expected_no_SCBs);
	main_sel_clauses.reserve(max_path_length); //where we've selection clauses for NW_SCBs and NW_TDRs
	if (apply_both_retargeting) //to save spaces for records associated with (NW_TDRs' retargeting with MDFS, NW_TDRs' retargeting with MPO_DFS)
		expansion = 2;

	if (!retarget_all_TDRs)
		NW_TDRs.reserve(1 * expansion); //only save one place for the target reg
	else
		NW_TDRs.reserve(expected_no_TDRs * expansion);

	//all the *Below* expectations are by trying and not dependant on a mathematical proved formula!!
	VN.reserve(max_path_length);
	AP.reserve(max_path_length);
	AVs.reserve(max_path_length);
	AN.reserve(max_path_length);
	CN.reserve(max_path_length);

	//Since NW_SDG connection file for the network is Not always available we need to check about that, so this section to not to save space in memory for nothing. 
	if (NW_SDG_file_exist)
	{
		SDG_con_clauses.reserve(max_path_length * 4);	//(*4) just a number chose by try and error
		SDG_VN.reserve(max_path_length * 4);
		SDG_AP.reserve(max_path_length * 3);
		AVs_sorted.reserve(max_no_timeFrames);
	}

	//for 2D vectors, we reserve here only the memory for outer vectors that carry each time frame information, while inner vectors would be reserved before each pushing to the outer vector.
	n_tracedNodes.reserve(max_no_timeFrames);
	AVs_total.reserve(max_no_timeFrames);
}

void node::load_NW(bool retargeting_or_upperBound, const string& NW_clauses_file, const string& NW_smv_pdl_file, const string& NW_SDG_file, bool retarget_all_TDRs)
{
	if (retargeting_or_upperBound)
	{
		if (!retarget_all_TDRs) //if (not true) set the target_reg from pdl file, otherwise the target_reg should be updated from (NW_TDRs) where the target is to access all network TDRs
		{
			load_input_files(NW_clauses_file, Selection_clauses);	//to assign the main_sel_clauses
			load_input_files(NW_smv_pdl_file, smv_pdl);				//to assign the target_reg
		}
		else //set all NW's TDRs while getting the selection_clauses
			load_input_files(NW_clauses_file, Selection_clauses_and_NW_TDRs);	//to assign the main_sel_clauses and collect all NW_TDRs

		if (NW_SDG_file != "")//because it is usually unavailable
			load_input_files(NW_SDG_file, SDG_connections);		//to assign the SDG_con_clauses
	}

	else //in case of CSU_upperBound_computation, I need only to load NW clauses
		load_input_files(NW_clauses_file, Selection_clauses);
}

void node::initialize_NW()
{
	rootptr = new node(target_reg, 0, 0);
	VN.emplace_back(rootptr->reg_id, rootptr);
	
	n_tracedNodes.emplace_back();	//push an empty value to be adjusted later through MDFS and MPO_DFS structured retargeting
	n_tracedNodes.back().reserve(max_no_children_per_SIB); //to reserve memory for each inner vector

	set_SCBStates();				//this method have to be called first before update_nodes() and print_AP(); in order to set the node's active and satisfy attributes correctly (the calling order is important)
	generate_SCT(*rootptr);
	generate_unVisitedNodes_SCT();	//this method check the activation of other non_visited nodes
	update_nodes_states(*rootptr);

	cout << "\n//////////////////////////////////////////////////////////////////";
	SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	cout << "\n*******For " << target_reg << ": *******\n";
	SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
	cout << "The Active Scan Path is:\n";
		print_AP(); //To print the active scan path before running the structured retargeting
	SetConsoleTextAttribute(hStdout, 15); //set back to black background and white text
}

void node::initialize_NW_withConflictChecking()
{
	rootptr = new node(target_reg, 0, 0);
	VN.emplace_back(rootptr->reg_id, rootptr);
	
	n_tracedNodes.emplace_back();  //push an empty value to be adjusted later through MDFS and MPO_DFS structured retargeting
	n_tracedNodes.back().reserve(max_no_children_per_SIB);

	set_SCBStates();//this method have to be called first before update_nodes() and print_AP(); in order to set the node's active and satisfy attributes correctly (the calling order is important)
	generate_targetReg_SCT_withConflictChecking(*rootptr);
	generate_unVisitedNodes_SCT(); //this method check the activation of other non_visited nodes
	update_nodes_states(*rootptr);

	cout << "\n//////////////////////////////////////////////////////////////////";
	SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	cout << "\n*******For " << target_reg << ": *******\n";
	SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
	cout << "The Active Scan Path is:\n";
	print_AP(); //To print the active scan path before running the structured retargeting
	SetConsoleTextAttribute(hStdout, 15); //set back to black background and white text
}

node::~node()
{
	/*	
	//vector.push_back(x), 'x' will create an temporary variable. After the vector copy it to its own memory, the temporary variable is destructed, 
	//so this is why the destructor is called after each 'vector.push_back(x)' call.
	//in order to let the destructor work correctly I need to implement a copy constructor to do the copying operation in a coorect way, otherwise an exception will be thrown
	*/
	if (this->ptrToChildren)
	{
		for (int i = 0; i < noOfChildren; i++)
		{
			delete ptrToChildren[i];
		}
		delete[] ptrToChildren; 
		this->ptrToChildren = NULL; //ptrToChildren still exists, but it's a dangling pointer now, so we set it to NULL (or 0), because delete doesn't delete the pointer, but the object it points to
	}
		
	this->noOfChildren = 0;
}

void node::free_memory()
{
	if (rootptr != NULL) //this condition is not required at all, it is only for safety check:)
	{
		//this part is used to free the heap memory associated with the "Target Registers' trees" creation
		for (size_t i = 0, e = VN.size(); i < e; i++)
		{
			if (!is_SCB_SIB(VN[i].reg_id)) //destroy the trees associated with each SR
			{
				destroy_tree(*VN[i].address);

				delete VN[i].address; //free the heap address of target register itself
				VN[i].address = NULL;
			}
		}
	}
	
	//this part is used to free the heap memory associated with the "SDG" creation
	if (head != NULL)
	{
		destroy_SDG(*head);
		//after I return back, the head node will be deallocated/freed, but not NULLed
		head = NULL;
	}

}

void node::destroy_tree(node &x)
{
	//here I have to free the heap memory associated to every node (pointers to nodes), and the memory associated to the array of pointers (pointer to array of pointers to nodes)
	if (x.ptrToChildren != NULL)
	{
		for (int j = 0; j < x.noOfChildren; j++)
		{
			destroy_tree(*x.ptrToChildren[j]);
			
			delete x.ptrToChildren[j]; //free the heap address of each node
			x.ptrToChildren[j] = NULL;
		}

		delete[] x.ptrToChildren; //free the heap address of the array of pointers associated to each node
		x.ptrToChildren = NULL;
		return;
	}
	return;
}

void node::destroy_SDG(SDG_node &x)
{
	if (x.next.size() != 0) //means I reached the "TDI", where the path starts from "TDO"
	{
		for (size_t i = 0, e = x.next.size(); i < e; i++)
		{
			if (x.next[i] != NULL) //if it is NULL, then it means that the next node has been deleted by another node in the NW, and this node should be handled as a leaf node and do nothing to it
			{
				destroy_SDG(*x.next[i]);
				x.next[i] = NULL;
			}
		}

		x.next.clear(); //if all the node's next children are freed, then clear the vector to set its size to zero
	}
	if (x.next.size() == 0) //this is "if" condition and not just as regular "else", to recheck for the "x.next" pointer after each call return
	{
		//before deletion check that this node hasn't any other nodes pointing to it. otherwise, other pointers should point to NULL where this node will not be existent anymore.
		if (x.prev.size() > 1) //if more than one node is pointing to this node, then set those SDG_nodes to point to NULL (set their next vector to point to NULL instead of pointing to this unexist anymore node)
		{
			SDG_node* prevNode; //to point to the node original address and not just take a "COPY" of it
			for (size_t i = 0, e1 = x.prev.size(); i < e1; i++)
			{
				prevNode = x.prev[i];
				for (size_t j = 0, e2 = prevNode->next.size(); j < e2; j++)
				{
					if (prevNode->next[j] == &x)
						prevNode->next[j] = NULL;
					break;
				}
			}
		}

		delete &x;
		return;
	}
}

void node::reset_system()
{
	free_memory();  //for (Target reg trees, SDG connection graph)
	reset_all();
	reset_counters();
}

void node::generate_SCT(node &x)
{
	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
	{
		return;
	}

	string reg_id = "";
	int sat_value = 1;	 //this is the default value, until we found a negation(!), or some other different state ([0100]), which should be detected through the next loop.
	int n = 0;			 //represent number of children for each node;

	//This section is used to parse the selection clause and extract all the children
	for (size_t i = 0, e = x.selection_clause.size(); i < e; i++)
	{
		while ((x.selection_clause[i] != '^') && (i < e)) // 'OR' this have to be covered also
		{
			if (x.selection_clause[i] == '!')
			{
				sat_value = 0;
			}
			else if (x.selection_clause[i] == '[')
			{
				string state; //The default constructor defines an empty string (i.e "" ) with a size/length of zero.
				while (x.selection_clause[++i] != ']')
				{
					state += x.selection_clause[i];
				}
				sat_value = stoi(state, nullptr, 2);
			}
			else if (x.selection_clause[i] != ' ')// to exclude empty spaces
			{
				reg_id += x.selection_clause[i];
			}

			i++;
		}

		//This part is used to construct the tree of each child
		int pos = find(VN.begin(), VN.end(), reg_id) - VN.begin(); //'find' look for registers with the same (reg_id) only not (reg_id, sat_value)

		//This part is used to benefit from the sub tree creation of the previously visited nodes
		//but there may be other different nodes in 'main_sel_clause' array, so I need to check for them in 'generate_AP' method
		if (pos >= VN.size())
		{
			//I need to add the node after adjusting its attributes like 'x.ptrToChildren' so that the 'is_active(node &x)' can work correctly
			x.ptrToChildren[n] = new node(reg_id, x.depth + 1, sat_value); //adjust the node depth and sat_value, which differ from node to another even if two nodes have the same sub tree, here I'm saving the node's address in heap (and not the node itself) to save more memory (object node's size will be smaller) and to use the address in free heap operation
			VN.emplace_back((*x.ptrToChildren[n]).reg_id, x.ptrToChildren[n]);
			generate_SCT(*x.ptrToChildren[n]);
		}
		else //this section to copy subTree: please note in node_copying two values could differ from one node to another(sat_value, depth), so I need to update those values seperately according to the position of each node in the SCT.
			x.ptrToChildren[n] = new node(*VN[pos].address, x.depth + 1, sat_value);

		/////////////////////////////////

		n++;
		sat_value = 1; //reset values for the next round in the loop
		reg_id.clear(); // set size of string to 0 length

		//set tree height
		if (height < x.depth + 1)
			height = x.depth + 1;
	}
}

void node::generate_targetReg_SCT_withConflictChecking(node &x)
{
	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
		return;

	string reg_id = "";
	int sat_value = 1;
	int n = 0; 
	
	for (size_t i = 0, e = x.selection_clause.size(); i < e; i++)
	{
		while ((x.selection_clause[i] != '^') && (i < e))
		{
			if (x.selection_clause[i] == '!')
				sat_value = 0;

			else if (x.selection_clause[i] == '[')
			{
				string state;
				while (x.selection_clause[++i] != ']')
				{
					state += x.selection_clause[i];
				}
				sat_value = stoi(state, nullptr, 2);
			}

			else if (x.selection_clause[i] != ' ')
				reg_id += x.selection_clause[i];

			i++;
		}

		if (x == *rootptr)
			noOfRootVChildren++;

		int pos = check_existence(VN, *x.ptrToChildren[n], false);

		if (pos == -1)
		{
			x.ptrToChildren[n] = new node(reg_id, x.depth + 1, sat_value);
			VN.emplace_back((*x.ptrToChildren[n]).reg_id, x.ptrToChildren[n]);
			generate_targetReg_SCT_withConflictChecking(*x.ptrToChildren[n]);
		}
		else
		{
			x.ptrToChildren[n] = new node(*VN[pos].address, x.depth + 1, sat_value); //here I need to check the conflict through the sub-tree of the previsited node, where it contains also other previsited nodes
			check_conflict(*x.ptrToChildren[n]); //here I check the conflict for the previsited node itself

			//there must be another method call here, to check the conflict for the subTree after copying it
		}

		n++;
		sat_value = 1;
		reg_id.clear();

		if (height < x.depth + 1)
			height = x.depth + 1;
	}
}

void node::generate_SCT_2D_vector(const vector<reg> &x)
{
	if (x.size() == 0) //this is a loop breaking condition.
		return;

	else
	{
		//emplace a new record in the SCT for the new level, and for better performance reserve also memory for it.
		_2D_SCT.emplace_back();
		_2D_SCT.back().reserve(max_no_children_per_SIB);

		for (size_t n = 0, e = x.size(); n < e; n++)
		{
			size_t index = get_selection_clause_index(x[n].reg_id);
			string selection_clause = main_sel_clauses[index].selectionClause;
			if (selection_clause != "TRUE" && selection_clause != "true") //it means it is a leaf and half no children to loop on them
			{

				string ID = "";
				int sat_value = 1;

				//This section is used to parse the selection clause and extract all the children
				for (size_t i = 0, e = selection_clause.size(); i < e; i++)
				{
					while ((selection_clause[i] != '^') && (i < e)) // 'OR' this have to be covered also
					{
						if (selection_clause[i] == '!')
						{
							sat_value = 0;
						}
						else if (selection_clause[i] == '[')
						{
							string state; //The default constructor defines an empty string (i.e "" ) with a size/length of zero.
							while (selection_clause[++i] != ']')
							{
								state += selection_clause[i];
							}
							sat_value = stoi(state, nullptr, 2);
						}
						else if (selection_clause[i] != ' ')// to exclude empty spaces
						{
							ID += selection_clause[i];
						}

						i++;
					}

					_2D_SCT.back().emplace_back(ID, sat_value);
					sat_value = 1; //reset values for the next round in the loop
					ID.clear();
				}
			}
		}

		generate_SCT_2D_vector(_2D_SCT.back());
	}
}

void node::print_2D_SCT(const node& x) //print tree as branches, so it start from the root to the leaf of one branch and then jump to the next branch and print it same way from root to leaf.
{
	int i;

	cout << "node: " << x.reg_id << ", satissfied= " << x.satisfied << ", active= " << x.active << ", sat_value= " << x.sat_value << ", depth= " << x.depth << "\n";

	for (i = 0; i < x.noOfChildren; i++)
	{
		print_2D_SCT(*x.ptrToChildren[i]);
		cout << "\n";
	}
}

void node::printSDG(const SDG_node& x)
{
	
	cout << "node: " << x.reg_id << ", ";
	cout << "prev: ";
	if (x.prev.size() != 0)
	{
		for (size_t i = 0, e = x.prev.size(); i < e; i++)
			cout << x.prev[i]->reg_id << ", ";
	}
	else
	{
		cout << "NULL. ";
	}
	
	cout << "next: ";
	if (x.next.size() != 0)
	{
		for (size_t i = 0, e = x.next.size(); i < e; i++)
			cout << x.next[i]->reg_id << ", ";
	}
	else
	{
		cout << "NULL. \n";
		return;
	}
	cout << "\n";
	
	for (size_t i = 0, e= x.next.size(); i < e; i++)
	{
		printSDG(*x.next[i]);
	}	
} 

void node::generate_AP()
{
	for (size_t i = 0, e = VN.size(); i < e; i++)
	{
		if (is_active(*VN[i].address))
		{
			AP.emplace_back(VN[i]);
		}
	}
}

void node::set_SCBStates()
{
	std::sort(SCBstate.begin(), SCBstate.end(), doj::alphanum_more<std::string>()); //(alphanum_more): for descending order (5,4,3,..), while (alphanum_less): for ascending order (1,2,3, ..)
	// and print the vector to cout
	//std::copy(SCBstate.begin(), SCBstate.end(), std::ostream_iterator<std::string>(std::cout, "\n"));
	
	//this section is used to convert from string to bin 
	if ((NW_state.length() == 1) && (SCBstate.size() > 1)) //in general (NW_state.size() < SCBstate.size()) and specifically when (NW_state.size() == 1).
	{
		for (size_t n = 0, e = SCBstate.size(); n < e; n++) //here I used 'SCBstate_adjustedSize' and not 'SCBstate.size()', where I need to consider the registers length and not only their numbers while generating the SCBstate[n].state
			SCBstate[n].state = NW_state[0] - '0'; //NW_state[0] because NW_state in this case is only one bit
	}

	else // (NW_state.size() >= SCBstate.size())  :(>) in case that I have SCBs with more than one bit (length>1)
	{
		for (size_t n = 0, i = 0, e1 = NW_state.length(); i < e1; i++) 
		{
			if (SCBstate[n].length == 1)
					SCBstate[n++].state = NW_state[i] - '0';
			
			else
			{
				string state = "";
				for (unsigned int j = 0; j < SCBstate[n].length; j++)
					state += NW_state[i++];
				SCBstate[n].state = stoi(state, nullptr, 2);

				i--; //to adjust the i_index (return it back) after the last decrement during the exiting from the previous loop (j_loop)
			}
		}
	}
}

void node::update_SCBStates(vector<reg> &p)
{
	for (size_t j = 0, e = p.size(); j < e; j++)
	{
		int pos = check_existence(SCBstate, p[j].reg_id);
		if (pos != -1)
			SCBstate[pos].state = p[j].state;
	}
}

bool node::is_satisfied(const node& x)
{
	for (size_t i = 0, e = SCBstate.size(); i < e; i++)
	{
		if (x.reg_id == SCBstate[i].reg_id)
		{
			if (x.sat_value == SCBstate[i].state)
				return true;
			else
				return false; //Not satisfied
		}
	}
	return false;
}

bool node::is_active(const node& x)
{
	//active nodes either are leaf nodes or having all children satisfied

	if (x.selection_clause == "TRUE" || x.selection_clause == "true") //it means it is a leaf
		return true;

	for (int i = 0; i < x.noOfChildren; i++)
	{
		if (!is_satisfied(*x.ptrToChildren[i]))
			return false;	
	}
	return true;
}

void node::update_nodes_states(node &x)
{
	if (is_active(x))
		x.active = true;
	else
		x.active = false;

	if (is_satisfied(x))
		x.satisfied = true;
	else
		x.satisfied = false;

	// check if it is a leaf node or not
	if (x.ptrToChildren != NULL)
	{
		for (int i = 0; i < x.noOfChildren; i++)
			update_nodes_states(*x.ptrToChildren[i]);
	}
	else 
		return;		
}

void node::set_initial_configuration()
{
	for (size_t n = 0, e = SCBstate.size(); n < e; n++) //here I used 'SCBstate_adjustedSize' and not 'SCBstate.size()', where I need to consider the registers length and not only their numbers while generating the SCBstate[n].state
		SCBstate[n].state = -1; //set initial_configuration (NW_state) to (any state)/(-1).
}

void node::set_target_configuration()
{
	for (unsigned int i = 0; i < rootptr->noOfChildren; i++)
		rootptr->ptrToChildren[i]->sat_value = -2; //set target_configuration to (any state)/(-2).
}

void node::MPO_DFS(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);

	while (!(*rootptr).active)
	{
		if (!x.active)
		{
			if (!x.satisfied) //1- (!Active ^ !Satisfied)
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MPO_DFS(*x.ptrToChildren[i]);
					/* //this condition can be used in optimization but for now let's keep it coherant with Dr. pesuode code, we need to do post order depth first search (loop on ALL children before return back to the parent)
					if ((*rootptr).active) //this condition is needed to stop traversing the remaining root's children if conflict has been resolved, (where if any deep node caused any dissatisfaction to root's children, then we need to re-traverse root's children to satisfy them again, but we don't have to traverse them all or in other words we should stop by the moment at which the target register become accessible)
					{
						break; //this cond can be used also as a code ENHANCEMENT, where even for non conflict situations, in MPO_DFS satisfying deepest nodes first may satisfy also root's children and higher nodes (above nodes), so in some cases like after tree sorting I may found that with later cycles, all the remaining root's children are already satisfied even without traversing them.
					}
					*/
				}

				//recheck the parent after satisfying its children, it may now been activated
				if (x.active && (x.reg_id != rootptr->reg_id)) //not to include root node in this condition, to resolve any upcoming conflict
				{
					n_tracedNodes.back().emplace_back(x.reg_id);   //to include the parent RE-Tracing

					int pos = check_existence(AN, x, false);
					if (pos == -1) //(-1) means there is no node with the same (reg_id)
						AN.emplace_back(x.reg_id, &x);

					else //if this node exists before in AN, then don't push it again but only update it with the new 'sat_value'
						(*AN[pos].address).sat_value = x.sat_value;

					satisfy_node();
					n_tracedNodes.emplace_back();
					n_tracedNodes.back().reserve(max_no_children_per_SIB);
					return;
				}
				else if (x.reg_id == rootptr->reg_id) //and (x.active or !a.active),I have to include the root_reg as a re-traced node; because "n_tracedNodes.back().push_back(x.reg_id)" is outside the while loop "while (!(*rootptr).active)", so when I return to the while the target_reg will not be considered
				{
					n_tracedNodes.back().emplace_back(x.reg_id);
				}
			}
			//2- (!Active ^ Satisfied)
			if (x.reg_id != rootptr->reg_id) //this cond is required for dynamic conflict resolution; where earlier nodes (root's children) may become unsatisfied while traversing, so I need to continue looping on them until they become so
				return; 
		}
		else if (!x.satisfied)//3- (Active ^ !Satisfied)
		{
			int pos = check_existence(AN, x, false);
			if (pos == -1)
				AN.emplace_back(x.reg_id, &x);

			else //if this node exists before in AN, then don't push it again and update it only with the new 'sat_value'
				AN[pos].address->sat_value = x.sat_value;

			satisfy_node(); //Even if AN is cleared each satisfying time, Old AN values would be already saved in SCBState vector while calling 'update_SCBState()' method to transfer the satisfying action to the network current state by setting the SCB/SIB
			n_tracedNodes.emplace_back();
			n_tracedNodes.back().reserve(max_no_children_per_SIB);
			return;
		}
		else //4- (Active ^ Satisfied), then there is no need to shift a dedicated vector for satisfying it.
			return;
	}
	/*
	//Print the final active scan path when the target register could be accessed
	if(x == *rootptr) //this condition is needed because one branch may satisfy also the remaining root's children, so when I do the recursion for them the while loop will be already satisfied
		generate_AVs(); //to concatenate AVs, I have to call [generate_AVs, generate_AP()] without calling AN.clear(); to concatenate active node each time
	*/
}

void node::MDFS(node &x)
{
	n_tracedNodes.back().emplace_back(x.reg_id);  

	while (! (*rootptr).active)
	{
		if (! x.active)
		{
			if (!x.satisfied) //Not Active and Not Satisfied
			{
				for (int i = 0; i < x.noOfChildren; i++)
				{
					MDFS(*x.ptrToChildren[i]);
				}

				if (&x == rootptr) //I can't reach here unless if the MDFS for the whole tree is completed and I returned back by recursion to the first point (root node) 
				{
					//If I reached here it means a complete tree traversal has been done
					MDFS_conflict_resolution();		//to generate SAN (Set of Selected Active Nodes) from AN 
					satisfy_node();	
					
					n_tracedNodes.emplace_back();	//new row for the next tree traversal
					n_tracedNodes.back().reserve(max_no_children_per_SIB);
					n_tracedNodes.back().emplace_back(rootptr->reg_id);
					//OR I can only say (n_tracedNodes.push_back({ rootptr->reg_id });) instead of above three commands, but above is better performance wise, where I reserve expected memory allocated each time so that no vector's resizing could happen.
				}
				else // (if x != *rootptr) this check is done after looping on all node's children.
					return;
			}
			else //Not Active but Satisfied
				return;
		}
		else //Active node
		{
			AN.emplace_back(x.reg_id, &x);
			return;
		}
		////Any return above means take the next node (next child) inside the recursion of 'MDFS(x.ptrToChildren[i]);'////

	//Carry out a new traversal until the root node becomes active
	}
	//Print the final active scan path with the target register being accessed
	//generate_AVs();
}

void node::MDFS_conflict_resolution()
{
	//if (AN[i].address->depth > AN[j].address->depth) //keep the one with the largest depth or the deepest one --> erase(j).
	//else if(AN[i].address->depth < AN[j].address->depth) --> erase(i).
	//else //(*AN[i].address).depth == (*AN[j].address).depth, then choose the "most left one", or the one "whose inserted first" in the [AN] vector, i.e. the one with the "smaller index". and because we are sure that (j_index > i_index), since we have started from (j=i+1), --> erase(j).
	
	size_t i, j; 

	for (i = 0; i < (unsigned int)AN.size() - 1; i++) //I can't add (e1 = AN.size() - 1, e2 = AN.size();) because it needs to be "redetermined" each loop since some inner modifications (like erase action) is done on (AN) vector each iteration.
	{
		j = i + 1;
		while (j < (unsigned int)AN.size())
		{
			if (AN[i].reg_id == AN[j].reg_id)
			{
				if (AN[i].address->depth > AN[j].address->depth || (*AN[i].address).depth == (*AN[j].address).depth)
					AN.erase(AN.begin() + j);
				else
				{
					AN[i] = AN[j]; //this section to adjust the indices if AN[i].depth < AN[j].depth
					AN.erase(AN.begin() + j); //(+j) not (+i) because I already stored A[j] into A[i]
				}
			}//No j++; because the erase action made the pointer automatically points to the next element, no need for increment
			else
				j++; //check the conflict of the next element
		}
	}
}

void node::generate_AVs() //used to generate ordered bit vector constructed from SAN, previously satisfied and the reset values
{
	int state, pos;

	//AVs is generated using the AN and AP vectors: //I need also to consider "active" but "not_MDFS_traversed" nodes while generating the ASP. I may have some "Active" nodes with (satisfied children) however those nodes were not traversed in the SCT and hence were not added to the AN vector; may be because the node's parent was already active or satisfied so MDFS traversal stops before reaching to those nodes; that's why we may found (AP.size() > AN.size())
	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		//only 'state' value needs to be re-adjusted based on the node's associativity (if it is belong to AN, then it needs to be satisfied with the required 'sat_value', if it is not and it was an SCB/SIB then use its corresponding 'state' value from the SCBState vector, otherwise reset it to be excluded from the A.S.P)
		pos = check_existence(AN, *AP[i].address, false);
		if (pos != -1)
			state = (*AN[pos].address).sat_value;
		else //if it is an SCB/SIB, then set it based on its old value from the SCBstate vector (its value in the previous CSU should be shifted and updated in NW_current_state or NW_SCB_states), otherwise use the reset value .
		{
			pos = check_existence(SCBstate, AP[i].reg_id);
			if (pos != -1)
				state = SCBstate[pos].state;
		}

		AVs.emplace_back(AP[i].reg_id, state, (*AP[i].address).length);
	}
	AVs_total.emplace_back(AVs);

	n_CSU_cycles++;
	adjust_scanPath_len();
	//print the output AVs vector each tree traverse
	//std::sort(AVs.begin(), AVs.end(), doj::alphanum_less<std::string>()); //means sort in ascending order;
	//print_AVs();
}

void node::print_AVs()
{
	for (size_t n = 0, e = AVs.size(); n < e; n++)
	{
		if (is_SCB_SIB(AVs[n].reg_id))
		{
			cout << AVs[n].reg_id << ": ";
			for (int i = AVs[n].length - 1; i >= 0; i--)//FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
			{
				cout << ((AVs[n].state >> i) & 1);
			}
			cout << ", ";
		}
		else //for TDR access print 'XXX'
		{
			cout << AVs[n].reg_id << ": " << "X, ";
		}

	}
	cout << "\n\n";
}

void node::print_AVs_total()
{
	for (size_t i = 0, e1 = AVs_total.size(); i < e1; i++)
	{
		cout << "CSU(" << i + 1 << "): ";
		for (size_t j = 0, e2 = AVs_total[i].size(); j < e2; j++)
		{
			if (is_SCB_SIB(AVs_total[i][j].reg_id))
			{
				cout << AVs_total[i][j].reg_id << ": ";
				cout << AVs_total[i][j].state;							//print decimal value
				/*for (int n = AVs_total[i][j].length - 1; n >= 0; n--)	//n should be (int) to be able to hold (-1). FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
				{
					cout << ((AVs_total[i][j].state >> n) & 1);			//print binary value
				}*/
				cout << ", ";
			}
			else //for TDR access print 'XXX'
			{
				cout << AVs_total[i][j].reg_id << ": " << "X, ";
			}
		}
		cout << "\n\n";
	}
}

void node::clear_vectors()
{
	AVs.clear();
	AN.clear();
	AP.clear();

	VN.clear();
	CN.clear();
	SDG_AP.clear();
	SDG_VN.clear();
	AVs_total.clear();
	AVs_sorted.clear();

	n_CSU_cycles = 0;
	scanPath_len = 0;
	n_tracedNodes.clear();
}

void node::reset_vectors()
{
	AVs.clear();
	AN.clear();
	AP.clear();
}

void node::reset_all()
{
	/*
	https://www.techiedelight.com/delete-vector-free-memory-cpp/
	If you want to reset you vector back to a empty state then we can use the swap trick to swap the contents of the vector into a temporary that will get destroyed and free the memory
	This will create a temporary empty vector, swap it with the one you have so now it is empty and then destroy everything in the temporary vector.
	//std::vector<string>().swap(NW_SCT_to_SAT_clauses);
	OR
	NW_SCT_to_SAT_clauses.clear();
	NW_SCT_to_SAT_clauses.shrink_to_fit();
	*/

	//Because in (reset_vectors()) they were only cleared!!
	std::vector<reg>().swap(AVs);
	std::vector<node_address>().swap(AN);
	std::vector<node_address>().swap(AP);

	std::vector<node_address>().swap(VN);
	std::vector<node_address>().swap(CN);
	std::vector<SDGnode_address>().swap(SDG_AP);
	std::vector<SDGnode_address>().swap(SDG_VN);
	std::vector<vector<reg>>().swap(AVs_total);
	std::vector<vector<reg>>().swap(AVs_sorted);

	// next section should be loaded only "once" for the whole network
	std::vector<reg>().swap(SCBstate);
	std::vector<reg>().swap(twiceSatisfying_SCBs);
	std::vector<selection>().swap(main_sel_clauses);
	std::vector<connection>().swap(SDG_con_clauses);
	std::vector<NWElement_statistics>().swap(NW_TDRs); 
	std::vector<vector<reg>>().swap(_2D_SCT);
}

void node::reset_counters()
{
	n_CSU_cycles = 0;
	scanPath_len = 0;
	std::vector<vector<string>>().swap(n_tracedNodes);
}

bool node::operator== (const node& x)
{
	if ((this->reg_id == x.reg_id))
		return true;
	else
		return false; //before doing the return, call the destructor to destroy (x node)
}

int node::check_existence(vector<reg> & p, const string& reg_id)
{
	reg temp{ reg_id , 0, 0 };
	int pos = find(p.begin(), p.end(), temp) - p.begin();
	if (pos < p.size())
	{
		return pos;
	}
	else
		return -1;
}

int node::check_existence(vector<node_address> &p, const node &x, bool enable_sat_valueChecking)
{
	int pos = find(p.begin(), p.end(), x.reg_id) - p.begin(); //here the comparison is based upon the 'reg_id' ONLY where the 'operator==' inside "node_address" struct is used, and this is the default scenario
	
	if (enable_sat_valueChecking)
	{
		if ((pos < p.size()) && (x.sat_value == p[pos].address->sat_value))
			return pos; //means there exist a node with the same 'reg_id' and 'sat_value'
		else if (pos < p.size())
			return -2; //means there exist a node with the same 'reg_id' but with different 'sat_value'
		else //here if the passed node with this 'reg_id' doesn't even exist.
			return -1;
	}
	else //here If I want to compare 'reg_id' only
	{
		if (pos < p.size())
		{
			return pos;
		}
		else//here if a node with this 'reg_id' doesn't even exist.
			return -1;
	}	
}

int node::check_existence(vector<SDGnode_address> & p, const string& reg_id)
{
	//I'm only interested to check for the existence of 'reg_id' value inside the passed vector

	int pos = find(p.begin(), p.end(), reg_id) - p.begin();
	if (pos < p.size())
	{
		return pos;
	}
	else
		return -1;
}

void node::generate_unVisitedNodes_SCT() //this method to include other non-visited registers (TDRs or SCBs) which are part of the whole NW tree, but aren't part of the target register tree
{
	for (size_t i = 0, e = main_sel_clauses.size(); i < e; i++) //here some OPTIMIZATIONs could be done, by using a vector 'main_sel_clauses' instead of a pointer to array and whenever any clause is traversed, we remove its corresponding clause from the vector meaning that we already finished with this clause, this will speed up the searching (for loop) mechanism a lot.
	{
		if (!is_SCB_SIB(main_sel_clauses[i].reg_id)) //This condition is NOT required but we add it in order to speed up the tree generation for Non-Visited nodes and make it limited to only the reg TDRs (which include structrual or temporal dependency with other SCBs/SIBs, so Non Visited SCBs/SIBs will be covered anyway)
		{
			//here I have to create "newNodes" in heap using the "new" operator, and not in stack by typing "node temp(main_sel_clauses[i].reg_id, 0, 0)" in order to keep these nodes saved in memory as long as we traverse over them and not being destructed once the function is finished 
			node* newNode = new node(main_sel_clauses[i].reg_id, 0, 0); //here I'm not interested with the 'state' and 'sat_value', I'm only interested with the (Active/Satisfied) characteristic of each node which could be deduced by examining the 'sat_value' of SCBs/SIBs nodes (which have been set correctly through the tree generation process of each Reg).
			if (check_existence(VN, *newNode, false) == -1)//false means check only for the Matching in 'reg_id'
			{
				VN.emplace_back(newNode->reg_id, newNode);
				generate_SCT(*newNode); //to adjust the children nodes of this node, so that 'is_active' can do the check correctly 
										//this have to be 'generate_tree' ALWAYS and not 'generate_tree_withConflictChecking'; because I don't have to check for conflict while generating the Active scan path by examining other nodes
			}
			else
			{
				//here if "newNode" was already in visited nodes (like Target register), then the constructor above will retain only the array of pointers without initializing each pointer to points to some nodes in heap, however because the above "if condition" would be "FALSE" then each pointer in the array will point to Nothing!! (nothing doesn't mean NULL), so we need to make it point to null so that no error would be thrown in destructor (~node) while destroying the heap addresses associated with each children "ptrToChildren[i]"
				for (int i = 0; i < newNode->noOfChildren; i++)
					newNode->ptrToChildren[i] = NULL;

				delete newNode;
			}

		}
	}

	//As a check 'VN.size()' should be equal to 'n_NWElements' to insure that all elements in the network are visited/examined
	if (VN.size() < main_sel_clauses.size())
	{
		for (size_t i = 0, e = main_sel_clauses.size(); i < e; i++)
		{
			node* newNode = new node(main_sel_clauses[i].reg_id, 0, 0);
			if (check_existence(VN, *newNode, false) == -1)
			{
				VN.emplace_back(newNode->reg_id, newNode);
				generate_SCT(*newNode);

				if (VN.size() == main_sel_clauses.size()) //recheck each time to stop looping if all NW elements have been traversed
					break;
			}
			else
			{
				//here if "newNode" was already in visited nodes (like Target register), then the constructor above will retain only the array of pointers without initializing each pointer to points to some nodes in heap, however because the above "if condition" would be "FALSE" then each pointer in the array will point to Nothing!! (nothing doesn't mean NULL), so we need to make it point to null so that no error would be thrown in destructor (~node) while destroying the heap addresses associated with each children "ptrToChildren[i]"
				for (int j = 0; j < newNode->noOfChildren; j++)
					newNode->ptrToChildren[j] = NULL;

				delete newNode;
			}
		}
	}
	
	generate_AP(); //check the activity and satisfy attrs of each node in the network to generate the AP
}

void node::print_AP()
{
	//std::sort(AP.begin(), AP.end(), doj::alphanum_less<std::string>()); //in ascending order

	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		int pos = check_existence(SCBstate, AP[i].reg_id);
		if (pos != -1)
		{
			cout << AP[i].reg_id << ": ";
			for (int j = AP[i].address->length - 1; j >= 0; j--)//FOR decimal values it have to be converted to bin first, in order to reveal the actual number of shifted bits
			{
				cout << ((SCBstate[pos].state >> j) & 1);
			}
			cout << ", ";
		}
		else //for TDR access print 'XXX'
		{
			cout << AP[i].reg_id << ": " << "X, ";
		}
	}
	cout << "\n\n";
}

node& node::operator= (const node& other) //https://www.youtube.com/watch?v=7LxepUEcXA4 // pass by reference always better than pass by value in performance because the pass-by-value parameter serves as a temporary (where it calls copy constructor internally to create a local object copied from the passed by value parameter) 
{
	//in equal assignment both nodes have same (deph, sat_value), which not the case in copy_subTree, where I usually have different values for (depth, sat_value)
	node(other, other.depth, other.sat_value);
	return *this;
}

void node::satisfy_node()
{
	generate_AVs();					//(1) generate one AV and shift it to the active scan path
	update_SCBStates(AVs);			//(2) update SCBState with the new satisfie values
	update_nodes_states(*rootptr);			//(3) upate nodes' state after each CSU cycle
	reset_vectors();				//(4) reset vectors for the new tree traversal (like AVs, AP)
	generate_AP();					//(5) generate the new active scan path, after satisfying each visited unsatisfied node
}

void node::check_conflict(node& x) //used to check the conflict between any node and root's visited children
{
	//in this method, I'm only interested with the root's first level children, where even if one child of the next levels becomes unsatisfed (because of conflict) it doesn't matter anymore because I already satsfied the parent, and this is what I'm interesred in and not the children. 

	unsigned int i;
	int pos = check_existence(CN, x, true); //true means check also for the similarity in 'sat_value'

	for (i = 0; i < noOfRootVChildren; i++)
	{
		if ((rootptr->ptrToChildren[i]->reg_id == x.reg_id))
		{
			if (((*(*rootptr).ptrToChildren[i]).sat_value != x.sat_value) && ((pos == -1) || (pos == -2)) ) //(-1) means the node doesn't exist originally, however (-2) means a node with the same 'reg_id' but different 'sat_value' does exist, we could say 'if (pos < 0)' instead. Both cases indicate that a node with exact circumference doesn't exist previously in CT, so we need to push this conflicted node
			{
				node* temp = new node(x.reg_id, 0, x.sat_value);

				CN.emplace_back(temp->reg_id, temp); //CT could carry multiple nodes with the same'reg_id' but each has a different 'sat_value' (i.e. 'sat_value' is an int variable which could carry decimal values (not boolean) like SREG, because of that I may have [(SREG_1, 1), (SREG_1, 3), (SREG_1, 5)]
				break;
			}
			else if(((*rootptr->ptrToChildren[i]).sat_value == x.sat_value) && (pos == -2))//this is required to be used as a CT reset, whenever a new node is visited but with the same root's child 'sat_value', then conflict no more exist, and if there were a node in CT with the same 'reg_id' had cause a conflict before, we need to remove it because the conflict has been resolved now by this new node(x)
			{
				pos = check_existence(CN, x, false); //here I'm disabling the 'sat_value' checking, because (pos =-2) means a node with same 'reg_id' does exist in CT, so to return were its exactly we need to disable the 'sat_value' checking and check for only 'reg_id' value.
				CN.erase(CN.begin() + pos); //remove the node which trigger the conflict flag, because this node (x) had removed the conflict situation by resatisfying the root children without any need to sort the tree.
				break;
			}
			break;//This is if one of root's children is equal to x.reg_id but both have the same 'sat_vaue' and (pos == -1) meaning this node doesn't exist primarily in CT vector, so no conflict and the node wasn't cause of any FORMERLY conflict, then break directly indicating No Conflict here 
		}
	}
}

void node::sort_tree(node &x)
{
	if (x.ptrToChildren == NULL)
	{
		x.weight = 1;
		return;
	}
	 //Doing this will cause the sorting to start from the leaf children up to the root node
	for (int i = 0; i < x.noOfChildren; i++)
	{
		sort_tree(*x.ptrToChildren[i]);
	}

	//(1) after checking all the leaf children weights, sort them
	for (int i = 0; i < x.noOfChildren - 1; i++)
	{
		for (int j = i+1; j < x.noOfChildren; j++)
		{
			if ((*x.ptrToChildren[i]).weight < (*x.ptrToChildren[j]).weight)
			{
				int pos1 = check_existence(VN, *x.ptrToChildren[i], false);
				int pos2 = check_existence(VN, *x.ptrToChildren[j], false);
				int pos3 = check_existence(AP, *x.ptrToChildren[i], false);
				int pos4 = check_existence(AP, *x.ptrToChildren[j], false);
				
				node temp;
				temp = *x.ptrToChildren[i];
				*x.ptrToChildren[i]  = *x.ptrToChildren[j];
				*x.ptrToChildren[j] = temp;
				
				//This section to update the nodes addresses after each swapping action
				//Because of the sorting action, now "VN" and "AP" vectors are corrupted where the elements' address member aren't more pointing to the correct address, where nodes addresses have been swapped while sorting the tree, so we need to update it
					VN[pos1].address = x.ptrToChildren[j]; 
					VN[pos2].address = x.ptrToChildren[i];
				if(pos3 != -1)// here we need to check if the swapped node belongs to the A.S.P or not, in contrast to VN, where any element should belong to it
					AP[pos3].address = x.ptrToChildren[j];
				if (pos4 != -1)
					AP[pos4].address = x.ptrToChildren[i];
				
			}
		}
	}

	//(2) Then update the weight of the parent node with the weight of the longest branch (first one) + 1
	x.weight = (*x.ptrToChildren[0]).weight + 1;
	return;
}

void node::MPO_DFS_conflict_resolution()
{
	sort_tree(*rootptr);
}

bool node::is_SCB_SIB(string& x)
{
	for (int i = 0; i < (sizeof(SCB_SIB)/sizeof(string)); i++)
	{
		if(x.find(SCB_SIB[i]) != std::string::npos)
			return true;
	}		

	return false;
}

unsigned int node::Inst_AccessTime()
{
	return (scanPath_len + (n_CSU_cycles * 4));
}

size_t node::get_selection_clause_index(const string& reg_id)
{
	size_t index, e = main_sel_clauses.size();

	for (index = 0; index < e; index++)
	{
		if (reg_id == main_sel_clauses[index].reg_id)
			return index;
	}
	if (index == e) //means there is a broken here, a reg not exist in the input selection array
	{
		cout << "ERROR: Reg: (" << reg_id << ") doesn't exist in network_selection clauses!!";
		exit(EXIT_FAILURE);

		return -1; //invalid index
	}
}

void node::apply_retargeting(bool structured_retargeting_method)
{
	void (node::*pointerToFn)(node &x); //this pointer is used to assign the address of a Fn to a pointer (or we can say assign function to variable), also this is a member pointer (A member pointer is a different type category from a ordinary pointer. The member pointer will have to be used together with an object of its class)
	
	if (structured_retargeting_method == true)
	{
		cout << "Using MDFS: \n";
		pointerToFn = &node::MDFS;
	}
	else
	{
		cout << "Using MPO_DFS: \n";
		pointerToFn = &node::MPO_DFS;
	}
		
	start = std::chrono::high_resolution_clock::now();
		initialize_NW();
		(*rootptr.*pointerToFn)(*rootptr); //(object.*pointer_name)(arguments);
	stop = std::chrono::high_resolution_clock::now();
	
	print_AVs_total();
	print_AP();		//just to make sure that the target_reg is finally active and included in the ASP.

	unsigned int accessTime = Inst_AccessTime();//Access time (CC)
	execution_time = stop - start;
	//float ms = execution_time.count() * 1000.0f;


	//"update" NW_TDRs[i] record with just measured statistics if it is exist, otherwise create a new one if it is not.
	for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
	{
		if (NW_TDRs[i].reg_id == target_reg)
		{
			if (NW_TDRs[i].n_CSU_cycles == 0) //means there is already a record for that TDR and I need only to update it with its assoicated measurements. 
				NW_TDRs[i] = { target_reg, n_CSU_cycles, accessTime, execution_time.count(), n_tracedNodes, structured_retargeting_method };
			
			else //means there exist a record with same id (NW_TDRs[i].reg_id) and it is also updated before, however I may need to insert a new one with (same id but different structured_retargeting_method), like inserting "two statistics for same target_reg" but one for MDFS readings and the other for MPO_DFS readings. 
				NW_TDRs.emplace_back(target_reg, n_CSU_cycles, accessTime, execution_time.count(), n_tracedNodes, structured_retargeting_method);
				

			break;
		}
	}
}

void node::apply_retargeting_withConflictChecking(bool structured_retargeting_method)
{
	//has the advatage of enhanced retargeting by sorting first generated SCTs
	//it uses (generate_SCT_withConflictChecking, initialize_NW_withConflictChecking, MPO_DFS_conflict_resolution)
	
	void (node::*pointerToFn)(node &x); //this pointer is used to assign the address of a Fn to a pointer (or we can say assign function to variable), also this is a member pointer (A member pointer is a different type category from a ordinary pointer. The member pointer will have to be used together with an object of its class)
	
	if (structured_retargeting_method == true)
		pointerToFn = &node::MDFS;
	else
	{
		if (!CN.empty()) //if there were any conflict while generating the tree using 'generate_tree_withConflictChecking' , then I need to sort the tree before applying the 'MPO_DFS'
		{
			cout << "Using MPO_DFS with Tree Sorting technique: \n";
			MPO_DFS_conflict_resolution();
			pointerToFn = &node::MPO_DFS;  //MPO_DFS(*node::rootptr);
		}
		else
			pointerToFn = &node::MPO_DFS;
	}

	start = std::chrono::high_resolution_clock::now();
		initialize_NW_withConflictChecking();
		(*rootptr.*pointerToFn)(*rootptr); //(object.*pointer_name)(arguments);
	stop = std::chrono::high_resolution_clock::now();
	
	print_AVs_total();

	unsigned int accessTime = Inst_AccessTime();//Access time (CC)
	execution_time = stop - start;
	//float ms = execution_time.count() * 1000.0f;

	//"update" NW_TDRs[i] record with just measured statistics
	for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
	{
		if (NW_TDRs[i].reg_id == target_reg)
		{
			NW_TDRs[i] = { target_reg, n_CSU_cycles, accessTime, execution_time.count(), n_tracedNodes, structured_retargeting_method };
			break;
		}
	}
}

void node::test_NW(bool structured_retargeting_method, const string& initial_state, const string& NW_clauses_file, const string& NW_smv_pdl_file, const string& NW_SDG_file, unsigned int children_per_SIB, unsigned int hierarchy_level, bool apply_both_retargeting, bool retarget_all_TDRs)
{
	bool NW_SDG_file_exist = (NW_SDG_file == "") ? false : true;

	//set (NW_state) and (target_reg)
	//First, I have to adjust vectors' capacity for better performance.
	//Second, I need to load selction clauses, NW_SDG connections and target_reg/NW_TDRs.
	//Third, I need to apply the structured retargeting according to the passed "type" (MDFS or MPO_DFS).  
	
	NW_state = initial_state;
	reserve_vectors_memory(children_per_SIB, hierarchy_level, retarget_all_TDRs, apply_both_retargeting, NW_SDG_file_exist);
	
	//load inputs(main_sel_clauses, SDG_con_clauses, SCBstate) only "once" for the all NW_TDRs tarversal
	load_NW(true, NW_clauses_file, NW_smv_pdl_file, NW_SDG_file, retarget_all_TDRs);

	//check If I want to gather statistics for the all NW TDRs or for only a specific target_reg_id 
	if (retarget_all_TDRs)
	{
		for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
		{
			//here I need to apply one more thing, which is to update the "target_reg" id each time in the loop with the name of (NW_TDRs[i].id)
			target_reg = NW_TDRs[i].reg_id;
			
			if (apply_both_retargeting) //apply structured retargeting two times, one using the MDFS retargeting and the other using MPO_DFS retargeting, so I need to call the same method "apply_retargeting" two times but with different passing parameter "structuring_method"
			{
				apply_retargeting(true);
				sort_AVs_and_validate_model(); //if the output wasn't valid, an error will be thrown, and the program should be terminated.
				print_NWstatistics(true, i);
				clear_vectors(); //clear all vectors and not reset/free their memory, to let theses vectors to be used later with other TDRs.

				apply_retargeting(false);
				sort_AVs_and_validate_model(); 
				print_NWstatistics(true, i);
				clear_vectors();
			}
			else
			{
				apply_retargeting(structured_retargeting_method);
				sort_AVs_and_validate_model(); 
				print_NWstatistics(true, i);

				clear_vectors();
			}
		}

		print_NWstatistics(false);

		//By the end I need to free all allocated memory
		reset_system();
	}
	else //apply structured retargeting for a specific "Target_reg"
	{
		if (apply_both_retargeting)
		{
			apply_retargeting(true);
			apply_retargeting(false);
		}
		else
			apply_retargeting(structured_retargeting_method);
	

		sort_AVs_and_validate_model(); 
		print_NWstatistics(true, 0);  //0: represent index of taregt_reg, since the option was to retarget only one TDR.

		reset_system();
	}
}

void node::print_NWstatistics(bool target_statistics, unsigned int index)
{
	//statistics for specific "target_reg"
	if (target_statistics)
	{
		cout << "\n//////////////////////////////////////////////////////////////////";
		SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		cout << "\n*******For " << NW_TDRs[index].reg_id << ": *******\n";
		cout << "\nNumber of Network Elements = " << main_sel_clauses.size() << ", Check of all_visited_flag = " << ((main_sel_clauses.size() == VN.size()) ? "Satisfied" : "Not Satisfied");
		cout << "\nNumber of TDR's = " << NW_TDRs.size();
		cout << "\nNumber of CSU cycles = " << NW_TDRs[index].n_CSU_cycles;
		cout << "\nInstrument Access Time = " << NW_TDRs[index].AccessTime;
		cout << "\nRetargeting took " << NW_TDRs[index].execution_time << " s";
		cout << "\nNumber of Traced Nodes for:\n";
		for (size_t i = 0, e1 = NW_TDRs[index].n_tracedNodes.size(); i < e1; i++)
		{
			cout << "access no.(" << i + 1 << ") =  " << NW_TDRs[index].n_tracedNodes[i].size() << " :[ ";
			for (size_t j = 0, e2 = NW_TDRs[index].n_tracedNodes[i].size(); j < e2; j++) //because one more row will be inserted to the end of the vector after the last satisfying step in MDFS/MPO_DFS, which hold nothing so it could be ignored
			{
				cout << NW_TDRs[index].n_tracedNodes[i][j] << ", ";
			}
			cout << "]\n";
		}

		SetConsoleTextAttribute(hStdout, 15);
		cout << "\n\n//////////////////////////////////////////////////////////////////\n";
	}

	//statistics for the "whole" NW	
	else
	{
		measurement max_SCT = get_max_SCT();
		cout << "\n//////////////////////////////////////////////////////////////////";
		SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);

		cout << "\nNumber of Network Elements = " << main_sel_clauses.size();// << ", Check of all_visited_flag = " << ((n_NWElements == VN.size()) ? "Satisfied" : "Not Satisfied");
		cout << "\nNumber of TDR's = " << NW_TDRs.size();
		cout << "\nFor Traced nodes NW parameter:\n" << "\tAvg= " << get_avg('T') << ", Max=" << get_max('T');
		cout << "\nFor #CSU / access NW parameter:\n" << "\tAvg= " << get_avg('C') << ", Max=" << get_max('C');
		cout << "\nFor Access time(CC) NW parameter:\n" << "\tAvg= " << get_avg('A') << ", Max=" << get_max('A');
		cout << "\nFor Max SCT size(node) NW parameter:\n" << "\tMax= " << max_SCT.reading << ", TDR_name=" << max_SCT.name;
		cout << "\nFor Execution time(sec) NW parameter:\n" << "\tAvg= " << get_avg('E') << ", Max=" << get_max('E');

		SetConsoleTextAttribute(hStdout, 15);
		cout << "\n//////////////////////////////////////////////////////////////////\n";

	}
}

double node::get_avg(char x) //A->access time, C->CSU cycles, E->execution time, T->Traced nodes
{
	double sum = 0;

	switch (x) {
		case 'A':
		{
			for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
			{
				sum += NW_TDRs[i].AccessTime;
			}
			return (sum / (unsigned int)NW_TDRs.size());
			break;
		}
		case 'C':
		{
			for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
			{
				sum += NW_TDRs[i].n_CSU_cycles;
			}
			return (sum / (unsigned int)NW_TDRs.size());
			break;
		}
		case 'E':
		{
			for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
			{
				sum += NW_TDRs[i].execution_time;
			}
			return (sum / (unsigned int)NW_TDRs.size());
			break;
		}
		case 'T':
		{
			int n_tracednodes_per_TReg;
			for (size_t i = 0, e1 = NW_TDRs.size(); i < e1; i++)
			{
				n_tracednodes_per_TReg = 0;
				for (size_t j = 0, e2 = NW_TDRs[i].n_tracedNodes.size(); j < e2; j++)
					n_tracednodes_per_TReg += NW_TDRs[i].n_tracedNodes[j].size();

				sum += n_tracednodes_per_TReg;
			}
			return (sum / (unsigned int)NW_TDRs.size());
			break;
		}
		default: std::cout << "Passed parameter isn't valid!!"; // no error
			return -1;
			break;
	}
}

double node::get_max(char x)
{
	switch (x) {
	case 'A':
	{
		double max = NW_TDRs[0].AccessTime;
		for (size_t i = 1, e = NW_TDRs.size(); i < e; i++)
		{
			if (max < NW_TDRs[i].AccessTime)
				max = NW_TDRs[i].AccessTime;
		}
		return max;
		break;
	}
	case 'C':
	{
		double max = NW_TDRs[0].n_CSU_cycles;
		for (size_t i = 1, e = NW_TDRs.size(); i < e; i++)
		{
			if (max < NW_TDRs[i].n_CSU_cycles)
				max = NW_TDRs[i].n_CSU_cycles;
		}
		return max;
		break;
	}
	case 'E':
	{
		double max = NW_TDRs[0].execution_time;
		for (size_t i = 1, e = NW_TDRs.size(); i < e; i++)
		{
			if (max < NW_TDRs[i].execution_time)
				max = NW_TDRs[i].execution_time;
		}
		return max;
		break;
	}
	case 'T':
	{
		int n_tracednodes_per_TReg = 0;
		for (size_t j = 0, e1 = NW_TDRs[0].n_tracedNodes.size(); j < e1; j++)
			n_tracednodes_per_TReg += NW_TDRs[0].n_tracedNodes[j].size();
		double max = n_tracednodes_per_TReg;

		for (size_t i = 1, e1 = NW_TDRs.size(); i < e1; i++) //here i start from (1) where max value has been set initially using the value at (i=0)
		{
			n_tracednodes_per_TReg = 0;
			for (size_t j = 0, e2 = NW_TDRs[i].n_tracedNodes.size(); j < e2; j++)
				n_tracednodes_per_TReg += NW_TDRs[i].n_tracedNodes[j].size();

			if (max < n_tracednodes_per_TReg)
				max = n_tracednodes_per_TReg;
		}
		return max;
		break;
	}
	default: std::cout << "Passed parameter isn't valid!!"; // no error
		return -1;
		break;
	}
}

measurement node::get_max_SCT()
{
	int n_tracednodes_per_TReg;
	measurement max_SCT;
	max_SCT.reading = 0;

	for (size_t i = 0, e = NW_TDRs.size(); i < e; i++)
	{
		//for (unsigned int j = 0; j < (unsigned int)NW_TDRs[i].n_tracedNodes.size(); j++)
		n_tracednodes_per_TReg = NW_TDRs[i].n_tracedNodes[0].size(); //take only the first Tracing vector for each NW_Reg or TDR, where in the first CSU I can get the total number of nodes in the TDR's SCT, since in MDFS we mostly traverse the whole tree in those benchmarks (heirarechy NWs).

		if (max_SCT.reading < n_tracednodes_per_TReg)
		{
			max_SCT.reading = n_tracednodes_per_TReg;
			max_SCT.name = NW_TDRs[i].reg_id;
		}

	}

	return max_SCT; //When returning a reference, be careful that the object being referred to does not go out of scope. So it is not legal to return a reference to local var. But you can always return a reference on a static variable., //https://stackoverflow.com/questions/752658/is-the-practice-of-returning-a-c-reference-variable-evil
}

void node::adjust_scanPath_len()
{
	for (size_t i = 0, e = AP.size(); i < e; i++)
	{
		scanPath_len += AP[i].address->length;
	}
}

void node::build_SDG(SDG_node &x)
{

	//SDG_con_clauses.size() != n_NWElements, where I have new different nodes for the SDG like (TDI, TDO, BR, SIB_SI, SIB_SO, I0_M1, ...)
	for (size_t i = 0, e1 = SDG_con_clauses.size(); i < e1; i++)
	{
		//Always insert nodes at the end
		if (x.reg_id == SDG_con_clauses[i].reg_id)
		{
			x.selection_control = SDG_con_clauses[i].selection_control;
			x.length = SDG_con_clauses[i].length;
			x.state = -1; //this is only an initial value, but it will be re-adujsted later to the correct state while invoking the setSCBStates() method. (-1) <--> uninitialized state

			vector <string> temp = SDG_con_clauses[i].next_OrderedNodes;
			//SDG_con_clauses.erase(SDG_con_clauses.begin() + i); //remove that element to speed up the search, (Not sure) because this vector resizing and elements resorting should also take time and it could be more than the searching/for loop above!!

			if (temp.size() != 0) //of if(x.reg_id != 'TDI')
			{
				for (size_t j = 0, e2 = temp.size(); j < e2; j++)
				{
					int pos = check_existence(SDG_VN, temp[j]);
					if (pos == -1)
					{
						x.next.emplace_back(new SDG_node{ temp[j] , "", 0, 0,{},{} });
						//this is to adjust the prev pointer of the next SDG nodes
						x.next[j]->prev.emplace_back(&x);//this can be adjusted also while creating the object by passing the correct values to the constructor "(new SDG_node{ temp[j] , "", 0, 0,{},{&x} });", here we did the same but through a push_back() command.

						SDG_VN.emplace_back(temp[j], x.next[j]);
						build_SDG(*x.next[j]);
					}
					else
					{
						x.next.emplace_back(SDG_VN[pos].address);
						(*SDG_VN[pos].address).prev.emplace_back(&x);
					}
				}
			}
			else
				x.next = {};

			if ((&x != head) || ((&x == head) && (SDG_VN.size() == SDG_con_clauses.size())))
				return; //to stop the for loop if (if (x.reg_id == SDG_con_clauses[i].reg_id)) is reached
		}
	}
	if(SDG_VN.size() < SDG_con_clauses.size() ) //I have a return statement, so I will not reach here except if I processed all the "SDG_con_clauses" connection array, and if after that this condition is TRUE, then it means that there is a broken in NW connectivity here, a reg not exist in the input connection array
	{
		cout << "ERROR: Reg: (" << x.reg_id << ") doesn't exist in network_connection array!!";
		exit(EXIT_FAILURE);
	}
	/*
	//print the resultant SDG
	if(&x == head) ////means this is the 'TDO' node
		printSDG(x);
	*/
}

void node::generate_SDG_AP(SDG_node &x)
{
	SDG_AP.emplace_back(x.reg_id, &x);

	if (x.next.size() > 1) //then this is a SCB_SIB[] and I need to check the selection control signal to move into the correct path
	{
		int pos = check_existence(SCBstate, x.selection_control);
		if (pos != -1)
		{
			int selectionControl_value = SCBstate[pos].state;
			generate_SDG_AP(*x.next[selectionControl_value]); //Depending on that the next nodes are inserted in sorted way in the main function, so that their order in the next vector would be consistant with the selection control (i.e. if SREG=2 that's mean this is the third selection element in the next vector)
		}
	}
	else if(x.next.size() == 1)
	{
		generate_SDG_AP(*x.next[0]);
	}
	else //(x.next.size() == 0 || x.reg_id == "TDI")
	{
		return;
	}
}

void node::sort_AVs_and_validate_model()
{
	if (SDG_con_clauses.size() != 0) //means there exist a NW SDG connection input_file for this network, because it is possible to be not available.
	{
		head = new SDG_node({ "TDO", // reg_id
		"", //selection_control
		0, //state
		0, //length
		{}, //vector <SDG_node*> next
		{} }); //vector <SDG_node*> prev}); //head pointer hold the address of 'TDO' node

		SDG_VN.emplace_back(head->reg_id, head);

		//1- set SDG nodes clauses to be uesd later in building the SDG, which is already done while invoking the "initialize_NW" method

		//2- build SDG
		build_SDG(*head);

		//check that the unrequired SCBs are reseted (only the required ones through the A.S.P are setted)
		//3- set SCB states according to network state
		set_SCBStates();

		//4- Generate A.S.P from SDG and check if the generated AVs could be accessed through it or not
		generate_SDG_AP(*head);

		string reg_id;

		for (size_t i = 0, e = AVs_total.size(); i < e; i++)
		{
			AVs_sorted.emplace_back(); //AVs_sorted is a two dimensional vector, so every new loop I need to push an empty row, so it can be accessed and initialized (set) through the loop

			//check if all AVs_total[i][j] are accessable through the A.S.P, but here the check is done in opposite way (check that SDG_AP covers ALL the elements in AVs_total[i]) and this is to do the sort through the same step (using the same for loop)
			for (int n = SDG_AP.size() - 1; n >= 0; n--) //to generate the path from TDI to TDO and not the opposite like in SDG
			{
				reg_id = SDG_AP[n].reg_id;
				int pos = check_existence(AVs_total[i], reg_id); //not the opposite "check_existence(&SDG_AP, AVs_total[i])" , and this is to push items into "AVs_sorted" based on NW connectivity(SDG) and not based on "AVs_total" order
				if (pos != -1)
					AVs_sorted[i].emplace_back(AVs_total[i][pos]);
			}
			if (AVs_sorted[i].size() != AVs_total[i].size()) //there are only two possibilities (= or <), if (<) that's mean that Structured Retargeting technique is wrong where its trying to access unreachable reg..
			{
				//throw an ERROR!!
				throw "ERROR: Structured Retargeting is trying to access UN-REACHABLE register !!";
			}

			SDG_AP.clear();

			//5- update the SCBStates vector in order to generate the new A.S.P from the SDG, and then complete checking the remaining AVs_total array of vectors
			update_SCBStates(AVs_total[i]);
			generate_SDG_AP(*head);
		}

		SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
		//6- if all AVs_total[i] are accessable each in the corresponding cycle, then check that the target_reg is accessable by the end of retargeting
		if (check_existence(SDG_AP, target_reg) != -1)
			cout << "Retargeting for (" << target_reg << ") was done CORRECTLY :)\n";

		//7- print sorted AVs
		print_AVs_sorted();
	}
	else
		cout << "Please enter the NW_SDG connection file First!!\n";

}

void node::print_AVs_sorted()
{
	SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	cout << "Sorted AVs: \n";
	SetConsoleTextAttribute(hStdout, 15); 

	for (size_t i = 0, e1 = AVs_sorted.size(); i < e1; i++)
	{
		cout << "{ ";
		for (size_t j = 0, e2 = AVs_sorted[i].size(); j < e2; j++)
		{
			cout << AVs_sorted[i][j].reg_id << ": " << AVs_sorted[i][j].state << ", ";;
		}
		cout << "}\n";
	}
}

void node::load_input_files(const string& input_file, input_file_type option)
{
https://stackoverflow.com/questions/50188898/c-reading-data-from-a-txt-file-to-vector-of-struct

	std::ifstream data_file(input_file.c_str());
	string line;
	if (!data_file)
		printf("Cannot open the File : %s\n", input_file.c_str());

	else
	{
		switch (option)
		{
		case Selection_clauses:
		{
			string reg_id;
			string selectionClause;
			unsigned int reg_len;
			unsigned int reset_val;

			unsigned int itr; //char_iterator

			while(getline(data_file, line))
			{
				if (line.length() != 0)  //to ignore any new lines in the text 
				{
					reg_id = "";
					selectionClause = "";
					reg_len = 0;
					reset_val = 0;
					itr = 0;

					while (line[itr] != '"')
						itr++;			//Do Nothing, just increament the iterator
					while (line[++itr] != '"')
						reg_id += line[itr];

					while (line[++itr] != '"')
						itr++;

					//"SR-M1_2/14^SR-M1_1/4"
					while (line[++itr] != '"')
						selectionClause += line[itr];

					while (!isdigit(line[itr]))
						itr++;
					reg_len = line[itr] - '0';

					while (!isdigit(line[++itr]))
						itr++;
					reset_val = line[itr] - '0';


					main_sel_clauses.emplace_back(reg_id, selectionClause, reg_len, reset_val);

					//This part is used to collect all the SCBs and SIBs through the network inside the SCBState vector
					if (is_SCB_SIB(reg_id)) //check if it is SCB or SIB (C, SIB, SIBP, PSIB, SREG)
					{
						//check first if the SCB exists before in the SCBState vector or not
						if (check_existence(SCBstate, reg_id) == -1)
							SCBstate.emplace_back(reg_id, -1, reg_len); //state=-1 means it is set initially to the (unknown state/uninitialized state), until set_SCBStates() is called and set all NW_SCBs correctly based on the passed parameter the 'NW_state'.
					}
				}
			}
			break;
		}
		case smv_pdl:
		{
			getline(data_file, line);
			if (line.length() != 0)
			{
				unsigned int itr = 0;
				target_reg = "";

				while (line[itr] != ' ')
					itr++;

				while (line[++itr] != ' ')
					target_reg += line[itr];

				NW_TDRs.emplace_back(target_reg);
			}
			break;
		}
		case SDG_connections:
		{
			string reg_id;
			vector<string> next_OrderedNodes;
			string selection_control;
			unsigned int length;

			unsigned int itr; 

			while (getline(data_file, line))
			{
				if (line.length() != 0)
				{
					reg_id = "";
					next_OrderedNodes.clear();
					selection_control = "";
					length = 0;
					itr = 0;

					while (line[itr] != '"')
						itr++;			//Do Nothing, just increament the iterator
					while (line[++itr] != '"')
						reg_id += line[itr];

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
					{
						next_OrderedNodes.emplace_back();

						//"I0-Mux2-M2_2/30,I1-Mux2-M2_2/33"
						while ((line[itr] != ',') && (line[itr] != '"'))
							next_OrderedNodes.back() += line[itr++];

						if (line[itr] == '"')
							break;
					}

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
						selection_control += line[itr];

					while (!isdigit(line[itr]))
						itr++;
					length = line[itr] - '0';


					SDG_con_clauses.emplace_back(reg_id, next_OrderedNodes, selection_control, length);

				}
			}
			break;
		}
		case Selection_clauses_and_NW_TDRs:
		{
			string reg_id;
			string selectionClause;
			unsigned int reg_len;
			unsigned int reset_val;

			unsigned int itr; //char_iterator

			while (getline(data_file, line))
			{
				if (line.length() != 0)
				{
					reg_id = "";
					selectionClause = "";
					reg_len = 0;
					reset_val = 0;
					itr = 0;

					while (line[itr] != '"')
						itr++;
					while (line[++itr] != '"')
						reg_id += line[itr];

					while (line[++itr] != '"')
						itr++;

					while (line[++itr] != '"')
						selectionClause += line[itr];

					while (!isdigit(line[itr]))
						itr++;
					reg_len = line[itr] - '0';

					while (!isdigit(line[++itr]))
						itr++;
					reset_val = line[itr] - '0';


					main_sel_clauses.emplace_back(reg_id, selectionClause, reg_len, reset_val);

					if (is_SCB_SIB(reg_id))
					{
						if (check_existence(SCBstate, reg_id) == -1)
							SCBstate.emplace_back(reg_id, -1, reg_len);
					}
					else
						NW_TDRs.emplace_back(reg_id);
				}
			}
			break;
		}
		}
	}
}

void node::test_generated_Benchmarks(bool structured_retargeting_method, const string& NW_state, bool SIB_or_MUX, const string& folder_location, const string& NW_clauses_file, const string& NW_smv_pdl_file, const string& NW_SDG_file, bool apply_both_retargeting, bool retarget_all_TDRs)
{
	if (SIB_or_MUX == true)
	{
		unsigned int hierarchy_level;
		unsigned int no_children_per_SIB;
		unsigned int expected_number_of_instruments;
		string path = ""; //this should be updated each time in the loop according to (no_children_per_SIB, hierarchy_level)

		for (no_children_per_SIB = 1; no_children_per_SIB <= max_no_children_per_SIB; no_children_per_SIB++)
		{
			for (hierarchy_level = 1; hierarchy_level <= max_no_hierarchies; hierarchy_level++)
			{
				//don't "Test" this network if number of its TDRs exceed the limit
				expected_number_of_instruments = myPow(no_children_per_SIB, hierarchy_level);
				if (expected_number_of_instruments <= max_no_TDRs)
				{
					//update files' names
					path = folder_location + to_string(no_children_per_SIB) + "_children_per_SIB/" + to_string(hierarchy_level) + "_hierarchies/";
					
					//for both type of retargeting/ MDFS/ MPO_DFS *without* conflict resolving
					test_NW(structured_retargeting_method, NW_state, path + NW_clauses_file, path + NW_smv_pdl_file, path + NW_SDG_file, no_children_per_SIB, hierarchy_level, apply_both_retargeting, retarget_all_TDRs);
				}
				else
					break; //in case I reached the max number of TDRs, then stop looping on (hierarchy_level) and move to the next (children_per_SIB)
			}
		}

	}
	else //for MUX_based NWs
	{

	}
}

measurement node::get_CSU_upperBound(const string& initial_state, const string& NW_clauses_file, unsigned int children_per_SIB, unsigned int hierarchy_level)
{
	//Note: in CSU upper bound computations, rootptr: points to a reg with section_clause equal to "NW_SCBs_accessMerging" selection_clause.
	//1- set the initial state of all NW_SCBs to (-1) <--> "unknown/uninitialized" state. Which is done by default in node's class_constructor (node::node() this->sat_value = -1).
	//2- Generating the NW_SCT "MAX Width": using the "SCBs Access Merging", i.e. (Root = SCB1.x ^ SCB2.x ^ ... ^ SCBn.x), where (x) means that the target is at state which is also not satisfied "by default"..
	//3- Generating the NW_SCT "MAX Depth": using the "TDRs Active Checking", we need to look at all the TDRs in the network which exist in the ASP of other SCBs and check if we could deActivate them or deAccess them before configuring those SCBs or not? i.e. (if there exist a TDR with selection clause = SCB1 ^SCBy, and let's assume that SCBy could be accessed from a completely other different ASP (SCBy = !SCB1), and there exist another Non_Active SCBx (SCBx's selection_clause != TRUE) which exist in the same ASP of the TDR(SCBx = SCB1). Then it is more optimum to deActive the TDR using (!SCBy) before confuring the SCBx. That's why we may need to elongate the SCT by making SCBx selection clause = SCB1^!SCBy (or SCBy=!SCB1^!SCBy).
	//4- set the (active/inactive) state of each node on the network based on if it is a "leaf or not", because initially all nodes are not satisfied, so there is no point in using the (satisfiability check)
	//5- set the (sat_value) of root's children / "NW_SCBs_accessMerging" nodes or the nodes responsible for the target register configurations to (-2), this is to keep them all the time at the "unsatisfied state" until they all become active and hence could be updated with "any" satisfying state, indicating "any" target configuration accessability. (-2) <--> (any state)
	//6- for CSU computations, apply MDFS on the "NW_SCT/NW_SCBs_accessMerging_SCT".
	//V.I Note: "current configuration" is saved trough NW_SCBs'(state) variables, since NW_SCBs hold the (NW_state) current configuration/ the configuration we start from, while "target cofiguration" is saved through the (sat_value) variable of the root's children nodes.
	//V.I Note: (-1, unkown/ uninitialized state), (-2, any target state): the reason why we chose two different values for the initial_state(-1) and the target_state(-2) is that in case the SCT internal nodes didn't change in the SCB value(in case of independent SCB), then (SCB_state = node_sat_value = -1); however, we want to account for one satisfying CSU, that'chose the target_cong=-2, so that the MDFS consume one more CSU to satisfy that node from (-1 --> -2) or (any Initial[-1] --> any Target[-2]) and taking into consideration that Intial_state[-1] != Final_state[-2].

	measurement max_no_CSUs;
	NW_state = initial_state;
	reserve_vectors_memory(children_per_SIB, hierarchy_level);

	load_NW(false, NW_clauses_file, "");

	start = std::chrono::high_resolution_clock::now();
		set_initial_configuration();			//Here we set "all" NW_SCBs.state (Initital state) to (-1). This method have to be called first before update_nodes(); in order to set the node's active and satisfy attributes correctly. For CSU_upperBound we start the network from the (unknown state/uninitialized state), i.e. (-1), so we could be able to go from "any/UUninitialized" conficuration to "any/Unknown" configuration.
		SCBs_Access_Merging();					//Set the target_reg to be the access merging between all network's SCBs. 2- set the target_configuration to "any"/(-2) value.
		TDRs_deActivation_Checking();			//Check on Active TDRs if they could be deActivated/unSatisfied before configuring/satisfying the SCBs in their ASP.
		rootptr = new node(target_reg, 0, 0);
		n_tracedNodes.emplace_back();
		generate_SCT(*rootptr);
		add_SCT_additional_constraints();
		set_target_configuration();				//Here we set "all" NW_SCBs.state (Finallll state) to (-2). This is can be done by setting the (sat_value) of root's children (which represent the target_config) to the (any state) value or (-2) so we could be able to apply "any" target conficuration.
		update_nodes_states(*rootptr);			//only nodes with (Always active state or selection_clause=TRUE) will be active, because we are starting from initial Unknown state, so all children should be initially unsatisfied. So, in first CSU we are able to update only the (always active) SCBs or the leaf nodes.
		generate_AP();							//I need to set the Active path of the first time frame to be used in generating the AVs for that time frame
		MDFS(*rootptr);							//Apply MDFS on the SCT with MAX Width and MAX Depth
	stop = std::chrono::high_resolution_clock::now();
	
	print_2D_SCT(*rootptr);					//to check if the (active, satisfied, sat_value) where setted correctly or not.

	//this section only to print the retargeting output and it could be commented.
	cout << "////////////////////////////////////////////////////////\n";
	print_AVs_total();
	cout << "////////////////////////////////////////////////////////\n";

	max_no_CSUs.name = to_string(AVs_total.size());
	execution_time = stop - start;
	max_no_CSUs.reading = execution_time.count();
	
	reset_system();

	return max_no_CSUs;
}

void node::SCBs_Access_Merging()
{
	target_reg = V_TDR;  //V: for "virtual. This is acts like a virtual instrument with an (any/-2) target_configuration to be satisfied :)
	string SCBs_accessMerging_selectionClause = "";
	for (int i = SCBstate.size() - 1; i >= 0; i--) //int (not size_t) to allow "less than zero" check in (i < 0).
	{
		SCBs_accessMerging_selectionClause += SCBstate[i].reg_id; //for better performance in retargeting, I need to insert SCBs, starting with SCBs in MSB (most significant bits), to get the benifits of already sorted trees :)  
		if (i != 0) //don't add "^" after the last literal
			SCBs_accessMerging_selectionClause += " ^ ";
	}
	main_sel_clauses.emplace_back(target_reg, SCBs_accessMerging_selectionClause, NW_state.length(), 0);
}

void node::TDRs_deActivation_Checking()
{
	//We need to check on "5" things and they have to be asked with the following order using (else if):
	//1- Does the TDR has SCB in its selection_clause with a complete conflict or not? (SCB exist in different ASP); so, it could be used to deActive the TDR before moving to its ASP.
	//2- Does the TDR has any Non_Active SCB in its ASP? 
	//3- Does the SCB in (2) is not always Active? (means the SCB selection_clause != TRUE)
	//4- Are all the SCBs in the network don't "share" the TDR's selection_clause? (TDR's selection_clause is not part of any SCB selection_clause in the network)
	//5- Are all the SCBs in the network don't "share" the TDR's Negated_selection_clause? (TDR's Negated_selection_clause is not part of any SCB selection_clause in the network)
	//* If the answer for all the above "5" question was positive then add the (TDR's Negated_selection_clause) to the SCB in (2).
	
	reg conflicted_SCB;
	vector<reg> TDR_selClause_vector;
	twiceSatisfying_SCBs.reserve(SCBstate.size()); //because the max number is that all NW_SCBs are going to be statisfied two times and we could never exceed this limit.

	for (size_t index = 0, e = main_sel_clauses.size(); index < e; index++)
	{
		if ((!is_SCB_SIB(main_sel_clauses[index].reg_id)) && (main_sel_clauses[index].reg_id != V_TDR)) //Exclude only NW_TDRs
		{
			split_selection_clause_into_vectorOfClauses(main_sel_clauses[index].selectionClause, TDR_selClause_vector);
			conflicted_SCB = get_complete_conflict_SCB(TDR_selClause_vector); //get completely_unSatisfied_SCB

			if (conflicted_SCB.reg_id != "")// == "" means there is SCB in the TDR's selection_clause which exist in ASP other than the TDR's ASP.
			{
				if (isThere_SCB_inSame_ASP(TDR_selClause_vector)) //inside this method we ignore "always Active" SCBs with (selection_clause = TRUE). So, step (3) is internally included here.
				{
					if (!check_conflicted_SCB_existence(conflicted_SCB)) //Is there exist any SCB with selection_clause includes the conflicted_SCB? --> if it exists, then this means that the conflicted SCB is already included in the NW_SCT either with a "similar state" to the one in the TRD's selection_clause or with a "negated state". However, in both cases I will have nothing to add to the NW_SCT because the conflicted_SCB is already satisfied twice. We only seek for conflicted_SCBs which are satisfied only once through Target_configuration satisfying process and we need to satisf them one more time to deActivate their corresponding Active TDRs "before" configuring the SCBs with same ASP. if conflicted SCBs exist with Two times of satisfying then adding the confliced_SCB to the SCT will either stop or delay those SCBs from being active and satisfied and will cause waste in used clock cycles; that's why we break once we discover that the conflicted_SCB is already has two times of satisfying. 
						twiceSatisfying_SCBs.emplace_back(conflicted_SCB.reg_id, !conflicted_SCB.state, conflicted_SCB.length); //If it is doesn't exist in any SCB.selection_clause which means it is satisfied only once to the target_configuration, then satisfy this SCB Twice: First, to satisfy the TDR's Negation/Unsatisfying to deActivate the TDR before configuring/satisfying other SCBs which exist in its ASP. Second, to satisfy the target_configuration. We want to shift the opposite satisfying state or add it to the NW_SCT as an additional constraints to be used in deActivation some NW_TDRs before accessing the SCBs in TDRs' ASP.
				}
			}
		}
	}
}

void node::remove_repetitions_in_SCT()
{
	unsigned int n = 0;		//loop on SCT_height/depth
	size_t i, e;

	while (n < height)
	{
		e = _2D_SCT[n].size();
		for (i = 0; i < e - 1; i++) //i loop until (e-1), j loop until (e)
		{
			for (size_t j = i + 1; j < e; j++)
			{
				if ((_2D_SCT[n][i].reg_id == _2D_SCT[n][j].reg_id) && (_2D_SCT[n][i].state == _2D_SCT[n][j].state)) //this is a repeated node through the same level.
				{
					_2D_SCT[n].erase(_2D_SCT[n].begin() + j);
					e--;		//because by any erase action would decrease the size by one. 
					j--;		//to adjust the pointer to not to drop any elements from the checking
				}
			}
		}

		n++;
	}
}

unsigned int node::n_conflicts_per_level(unsigned int SCT_level)
{
	unsigned int conflicts_per_level = 0;	
	
	for (size_t i = 0, e = _2D_SCT[SCT_level].size(); i < e; i++) //here I can't call (check_existance) because I don't want to check if it is exist before or not, however I need to check how many times it exists before.
	{
		for (size_t j = 0; j < e; j++)
		{
			if ((_2D_SCT[SCT_level][i].reg_id == _2D_SCT[SCT_level][j].reg_id) && (i != j)) //here I can't use directly (check_existance) because I need to check one more condition (i != j), which doesn't return by (check_existence) in case it exists.
			{
				conflicts_per_level++;
				break; //for correct computations I need to count for the conflicts of each (SCT[SCT_level][i]) seperately, by checking if each element in the vector exists before or not (i!=j).
			}
		}
	}

	if (conflicts_per_level == 0)
		return 1;			//(1) because by default I have to count at MIN "ONE" CSU for each SCT_level, to satisfy all unconflicted nodes.
	else
		return conflicts_per_level;
}

void node::split_selection_clause_into_vectorOfClauses(const string& selection_clause, vector<reg>& output_vector)
{
	//The implemenation of this method is different from the one in "generator.cpp", where there the (state) was always (true) for NW_struct1 or SIB_based networks
	//However now we can take an input from either an (input file) or from the (Generator) because of that we need to take SCB state into the considerations.
	istringstream selClause(selection_clause);
	string token;
	unsigned int itr;

	string id;
	string state_str_value;
	int state;

	output_vector.clear();	//in case it was used before in previous TDR's iterations.
	size_t n = std::count(selection_clause.begin(), selection_clause.end(), '^');
	output_vector.reserve(n + 1); //A^B^C --> 2(^), 3(clauses).

	while (getline(selClause, token, '^'))
	{
		itr = 0;//reset variables for the next time
		id = "";
		state_str_value = "";
		state = true;

		if (token[itr] == '!')
		{
			state = false;
			itr++; //to ignore (!) char while generating the (id)
		}

		while (token[itr] != '[' && token[itr] != '\0')
			id += token[itr++];

		if (token[itr] == '[')
		{
			while (token[++itr] != ']')
				state_str_value += token[itr];

			state = std::stoi(state_str_value, nullptr, 2);
		}

		output_vector.emplace_back(id, state, (state_str_value.length() == 0 ? 1 : state_str_value.length()));
	}
}

reg node::get_complete_conflict_SCB(vector<reg>& TDR_selClause)
{
	//complete conflict means two things:
	//1- the two nodes can't be simultaneously active at the same CSU; their register selections can't be satisfied together ==> (TDR.ASP != SCB.ASP).
	//2- they can't have any SCB with common state value; because once the state of that common SCB is statisfied by the retargeter, the TDR will be active "before" the SCB that controls it, however, we want the opposite, we want the controlling SCB be acive first in order to be used in deactivating the TDR and hence get minimum retargeting cost! 
	reg conflicted_SCB;
	string conflicted_SCB_selClause;
	vector<reg> SCB_selClause;
	size_t i, j, e1, e2;

	for (i = 0, e1 = TDR_selClause.size(); i < e1; i++)
	{
		//the second loop to get the selection_clause of each SCB in the TDR's selection_clause
		for (j = 0, e2 = main_sel_clauses.size(); j < e2; j++) 
		{
			if ((main_sel_clauses[j].reg_id == TDR_selClause[i].reg_id) && (main_sel_clauses[j].selectionClause != "TRUE")) //we ignore in our for loop "Always Active" SCBs; because those Always_Active_Conflictes_SCBs are by default "satisfied multiple times" in each shifted CSU and not only two times!!
			{
				split_selection_clause_into_vectorOfClauses(main_sel_clauses[j].selectionClause, SCB_selClause);
				if (!is_simultaneouslyActive(TDR_selClause, SCB_selClause) && !has_SCB_inCommon(TDR_selClause, SCB_selClause)) //check if any SCB in TDR.selectClause has complete conflict/complete unsatisfing or not: check if there exist any common SCB with the same satisfying value between the two selection_clauses and hence complete conflict is not established.
				{
					if (conflicted_SCB.reg_id.empty())//not setted before!!
					{
						conflicted_SCB = TDR_selClause[i];
						conflicted_SCB_selClause = main_sel_clauses[j].selectionClause;
					}
					else //take the conflicted_SCB with the min_depth --> simplest to be satisfied and hence deActivating the corresponding TDR.
						conflicted_SCB = (std::count(conflicted_SCB_selClause.begin(), conflicted_SCB_selClause.end(), '^') < std::count(main_sel_clauses[j].selectionClause.begin(), main_sel_clauses[j].selectionClause.end(), '^')) ? conflicted_SCB : TDR_selClause[i];
				}
				else
					break;	//jump to the next TDR_selClause[i] and check if it has complete conflict/complete unsatisfying or not.
			}
		}
	}

	return conflicted_SCB;
}

bool node::isThere_SCB_inSame_ASP(vector<reg>& TDR_selClause)
{
	vector<reg> SCB_selClause;
	for (size_t i = 0, e1 = main_sel_clauses.size(); i < e1; i++)
	{
		if ((is_SCB_SIB(main_sel_clauses[i].reg_id)) && (main_sel_clauses[i].selectionClause != "TRUE")) //loop on all "Not Always Active" NW_SCBs and find the SCBs which exist in the same TDR's ASP and it selection_clause != "TRUE"; we exclude (Always_Active_SCBs) because our scope is to deActive NW_TDR "before" accessing them and this "before" action will never happen if the configured SCB is always part of the ASP. So, while we try to deActivate the TDR, the configured_SCB will be already accessd. So, "before" action will never be reached!!
		{
			split_selection_clause_into_vectorOfClauses(main_sel_clauses[i].selectionClause, SCB_selClause);
			if (is_simultaneouslyActive(TDR_selClause, SCB_selClause))
				return true; //there exist an SCB with which has the same TDR's ASP.
		}
	}
	return false;
}

bool node::check_conflicted_SCB_existence(reg& conflicted_SCB)
{
	vector<reg> SCB_selClause;
	for (size_t i = 0, e = main_sel_clauses.size(); i < e; i++)
	{
		if ((is_SCB_SIB(main_sel_clauses[i].reg_id)) && (main_sel_clauses[i].selectionClause != "TRUE") && (main_sel_clauses[i].reg_id != conflicted_SCB.reg_id))
		{
			split_selection_clause_into_vectorOfClauses(main_sel_clauses[i].selectionClause, SCB_selClause);
			if (check_existence(SCB_selClause, conflicted_SCB) != -1) //check if the passed (SCB) parameter already exist or not in the passed (selection_clause)
				return true;
		}
	}
	return false; //the "conflicted_SCB" doesn't exist before in any of the NW_SCBs's selection_clauses. So, it is exist only once in the NW_SCT to only satisfy the target_configuration. However, we may need to satisfy it twice one of them as an additional constraints to get more optimum path by deactivating some TDRs first using (conflicted_SCB.state) satisfying value and then activating them againg using the (target_configuration.state) satisfying value.
}

bool node::is_simultaneouslyActive(vector<reg>& TDR_selClause, vector<reg>& SCB_selClause)
{
	int pos;

	for (size_t i = 0, e = SCB_selClause.size(); i < e; i++)
	{
		pos = check_existence(TDR_selClause, SCB_selClause[i]);
		if (pos != -1)
		{
			if (TDR_selClause[pos].state != SCB_selClause[i].state)
				return false;  //we can't satisfy both the TDR and the SCB together and hence the can't ever share the same ASP.
		}
	}
	return true;
}

bool node::has_SCB_inCommon(vector<reg>& TDR_selClause, vector<reg>& SCB_selClause)
{
	//same id and same satisfying value: same(SCB.reg_id, SCB.state)
	int pos;

	for (size_t i = 0, e = SCB_selClause.size(); i < e; i++)
	{
		pos = check_existence(TDR_selClause, SCB_selClause[i]);
		if (pos != -1)
		{
			if (TDR_selClause[pos].state == SCB_selClause[i].state)
				return true;  //we can't satisfy both the TDR and the SCB together and hence the can't ever share the same ASP.
		}
	}
	return false;
}

void node::add_SCT_additional_constraints()
{
	int pos;
	unsigned int k = 0;

	for (size_t i = 0, e = twiceSatisfying_SCBs.size(); i < e; i++)
	{
		for (unsigned int j = 0; j < rootptr->noOfChildren; j++)
		{
			if (rootptr->ptrToChildren[j]->reg_id == twiceSatisfying_SCBs[i].reg_id)
			{
				//Now we have two differnet nodes and we need to generate another pointer to the new node (twiceSatisfying_SCBs[i]) with (one more child) which hold beside structural and temporal dependency, the additional Active_TDR constraints. We "CAN'T" benifit here from the "sub_tree" creation of the previously visited nodes. Because (twiceSatisfying_SCBs[i], rootptr->ptrToChildren[j]) are different nodes with different children and differnt selection clauses, i.e. (twiceSatisfying_SCBs[i])'s selection clause is depenendant on (structural and temporal dependency), however, (rootptr->ptrToChildren[j])'s selection clause will be updated to include also secondly satisfying nodes. 
				node** newPointer = new node*[rootptr->ptrToChildren[j]->noOfChildren + 1];
				for (k = 0; k < rootptr->ptrToChildren[j]->noOfChildren; k++)
					newPointer[k] = rootptr->ptrToChildren[j]->ptrToChildren[k];
				
				//add the additional child (second satisfying node)
				newPointer[k] = new node(twiceSatisfying_SCBs[i].reg_id, rootptr->ptrToChildren[j]->depth + 1, twiceSatisfying_SCBs[i].state);
				
				//Both nodes: the node with only (structural and temporal dependency) children and the node with (structural and temporal dependency + additional constraints) children should exist in the <VN> vector; because they are different nodes even if both share the same (reg_id). However, they have different (sat_value), different (no_children) and differnt (ptrToChildren). i.e. SCBx = SCB1^!SCBx, SCBx = SCB1; in first clause (SCBx) has two children ,however, in second clause (SCBx) has only one child. So, the SCBx with one child should be Active and Satisfied first before the outer (SCBx) with two children--> SCBx(first clause) should be satisfied "after satisfying" SCBx in (second clause); that's why I need to push the two nodes in the <VN> vector seperately.
				VN.emplace_back(twiceSatisfying_SCBs[i].reg_id, newPointer[k]);
				generate_SCT(*newPointer[k]);
 
				//update the SCT pointer. We can't delete the old pointer because it is still "in use" by the node we pushed into the <VN> vector. it is only not used be the SCT anymore were it has been replaced with the (twiceSatisfying_SCB) node.
				rootptr->ptrToChildren[j]->ptrToChildren = newPointer;
				rootptr->ptrToChildren[j]->noOfChildren++;
				break; //take the "next" two_times_of_satisfying_SCB element.
			}
		}
	}
}